
* Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

** Init
:PROPERTIES:
:ID:       71dbf82e-cf4f-4e8a-b14d-df78bea5b20f
:END:

*** gc cons threshold
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

A big contributor to long startup times is the garbage collector. When
performing a large number of calculations, it can make a big difference to
increase the [[helpvar:gc-cons-threshold][gc-cons-threshold]], or the /number of bytes of consing between
garbage collections/. The default value is usually too low for modern machines.

**** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

#+begin_src emacs-lisp
(defconst VOID-GC-CONS-THRESHOLD-MAX (eval-when-compile (* 256 1024 1024))
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst VOID-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
If you experience freezing, decrease this. If you experience stuttering,
increase this.")

(defconst VOID-GC-CONS-PERCENTAGE-MAX 0.6
  "The upper limit for `gc-cons-percentage'.
When VOID is performing computationally intensive operations,
`gc-cons-percentage' is set to this value.")

(defconst VOID-GC-CONS-PERCENTAGE 0.1
  "The default value for `gc-cons-percentage'.")
#+end_src

**** boost gc threshold
:PROPERTIES:
:ID: eac7cfbb-6576-4506-8118-5bfda151654b
:END:

Here I boost the gc-cons-threshold for my current emacs session. It will be
restored after package loading slows down.

#+begin_src emacs-lisp
(setq gc-cons-threshold VOID-GC-CONS-THRESHOLD-MAX)
(setq gc-cons-percentage VOID-GC-CONS-PERCENTAGE-MAX)
#+end_src

**** restore threshold after delay
:PROPERTIES:
:ID: d49bef67-0a1e-4026-838c-217b0d6ecad5
:END:

Restore gc-cons-threshold (after a 7 second delay). I got this from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el#L283][doom]]. We
don't do it immediately because packages are still being lazy loaded at this
time.

#+begin_src emacs-lisp
(defun void-restore-gc-cons-threshold ()
  "Restore `gc-cons-threshold' to `VOID-GC-CONS-PERCENTAGE' after 7 idle seconds."
  (void-log "Restoring...gc-cons-threshold: %d -> %d | gc-cons-percentage %.2f -> %.2f"
            gc-cons-threshold
            VOID-GC-CONS-THRESHOLD
            gc-cons-percentage
            VOID-GC-CONS-PERCENTAGE)
  (setq gc-cons-threshold VOID-GC-CONS-THRESHOLD)
  (setq gc-cons-percentage VOID-GC-CONS-PERCENTAGE))

(run-with-idle-timer 7 nil #'void-restore-gc-cons-threshold)
#+end_src

*** directories
:PROPERTIES:
:ID: 93cc2db1-44c7-45ec-af98-5a4eb7145f61
:END:

**** core directories and files
:PROPERTIES:
:ID: ad18ebcb-803a-4fd6-adcb-c71cf54f3432
:END:

***** top level
:PROPERTIES:
:ID: 48bf884a-de27-45f8-a5b1-94567815942d
:END:

These are important files and directories that I end up referring to often in my
code. Well, not so much =VOID-README-FILE= and =VOID-TODO-FILE= but the others are
referenced alot.

One of the ideas in Void is that good text documentation is not enough. I want
documentation that has screenshots, gifs, videos--anything that helps explain
behaviors, bugs features or whatever else I want to in emacs.

#+begin_src emacs-lisp
(defconst VOID-EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(defconst VOID-INIT-FILE (concat VOID-EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps Void startup.")

(defconst VOID-README-FILE (concat VOID-EMACS-DIR "README.org")
  "Path to the Org file that when that Void.")

(defconst VOID-MULTIMEDIA-DIR (concat VOID-EMACS-DIR "screenshots/")
  "Directory where any multimedia describing VOID should go.
 These could screenshots are for detailing any problems, interesting behaviors or features.")

(defconst VOID-TEST-FILE (concat VOID-EMACS-DIR "test.org")
  "Path to the file that contains all of Void's tests.")
#+end_src

***** org
:PROPERTIES:
:ID:       c88f95cd-f5bd-4c69-8679-7e42c52e9a36
:END:

#+begin_src emacs-lisp
(defconst VOID-ORG-DIR (expand-file-name "~/Documents/org/")
  "Path where Void's org files go.")

(defconst VOID-CAPTURE-FILE (concat VOID-ORG-DIR "capture.org")
  "File where all org captures will go.")
#+end_src

***** hidden
:PROPERTIES:
:ID: d46d573b-1d17-4d0b-9b49-9049dbb6f7c1
:END:

#+begin_src emacs-lisp
(defconst VOID-LOCAL-DIR (concat VOID-EMACS-DIR ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(defconst VOID-DATA-DIR (concat VOID-LOCAL-DIR "data/")
  "Path to the directory where Void data files are stored.")

(defconst VOID-PACKAGES-DIR (concat VOID-LOCAL-DIR "packages/")
  "Path to the directory where packages are stored.")
#+end_src

**** system directories
:PROPERTIES:
:ID:       f3bdd353-b0ff-48fd-a2f2-295ccfa139ab
:END:

These are directories I have on my system.

#+begin_src emacs-lisp
(defconst VOID-DOWNLOAD-DIR (expand-file-name "~/Downloads/")
  "Directory where downloads should go.")

(defconst VOID-MULTIMEDIA-DIR (expand-file-name "~/Multimedia/")
  "Directory where multimedia should go.")

(defconst VOID-VIDEO-DIR (concat VOID-MULTIMEDIA-DIR "Videos/")
  "Directory where videos should go.")

(defconst VOID-MUSIC-DIR (concat VOID-MULTIMEDIA-DIR "Music/")
  "Directory where music should go.")

(defconst VOID-ALERT-SOUNDS (concat VOID-MULTIMEDIA-DIR "Alert Sounds/")
  "Directory where alert sounds should go.")

(defconst VOID-EMAIL-DIR (expand-file-name "~/.mail/")
  "Directories where emails are stored.")
#+end_src

**** ensure directories exist
:PROPERTIES:
:ID: 56e80dda-5d0e-4c7c-a225-00d0028d4995
:END:

I create the directories that don't exist. But I assume they already exist if
Void is compiled.

#+begin_src emacs-lisp
(dolist (dir (list VOID-LOCAL-DIR VOID-DATA-DIR VOID-ORG-DIR))
  (make-directory dir t))
#+end_src

*** message logging
:PROPERTIES:
:ID:       4d4f4b4a-4fc3-47fe-bed7-acc8e8103933
:END:

Its not uncommon for the *Messages* buffer to become full of messages.

**** debug-p
:PROPERTIES:
:ID: b9e28d90-cdbe-412f-8ed8-1b8b97c1ab07
:END:

[[helpvar:void-debug-p][void-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable
is to serve as an indicator of whether the current Void instance is run for
debugging. When Void is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][void-log]].

#+begin_src emacs-lisp
(defvar void-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

**** logging
:PROPERTIES:
:ID: 84ded5f7-382e-4f59-af9e-ccb157ef5c42
:END:

The purpose of ~void-log~ is to distinguish regular messages from messages that
pertain specifically to Void, and to help debug Void functionality. When Void is
=void-debug= is non-nil, void-specific messages are logged in the =*messages*=
buffer.

#+begin_src emacs-lisp
(defun void-log (format-string &rest args)
  "Log to *Messages* if `void-debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
  (when void-debug-p
    (let ((inhibit-message (active-minibuffer-window)))
      (when void-debug-p
        (apply #'message (concat (propertize "VOID " 'face 'font-lock-comment-face)
                                 format-string)
               args)))))
#+end_src

*** default coding system
:PROPERTIES:
:ID:       4c55a0d4-dbd7-4405-b944-3b68d8a069f2
:END:

#+begin_src emacs-lisp
(defconst VOID-DEFAULT-CODING-SYSTEM 'utf-8
  "Default text encoding.")
#+end_src

*** UTF-8
:PROPERTIES:
:ID: dd0fc702-67a7-404c-849e-22804663308d
:END:

I set =utf-8= as the default encoding for everything except the clipboard on
windows. Window clipboard encoding could be wider than =utf-8=, so we let
Emacs/the OS decide what encoding to use.

#+begin_src emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

*** initial buffer choice
:PROPERTIES:
:ID:       8eb302a6-cbc0-40ed-a046-b4c2d3dbc997
:END:

#+begin_src emacs-lisp
(defun void-initial-buffer ()
  "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
  (if void-debug-p
      (get-buffer "*Messages*")
    (get-buffer "*scratch*")))
#+end_src

** Package Management
:PROPERTIES:
:ID: 0397db22-91be-4311-beef-aeda4cd3a7f3
:END:

This headine contains code related to the initialization of packages.

*** package managers
:PROPERTIES:
:ID:       8c5d69ee-cec5-4154-9d71-79168954574b
:END:

There are several package mangers possible to use with emacs. One of the nice
things about abstracting package configuration with =use-package= is that you can
change the package manager easily.

**** straight.el
:PROPERTIES:
:ID: a086d616-b90d-4826-b61f-93eb0b7efc8e
:END:

[[straight][straight.el]] is a package manager that strives to make emacs configurations
completely reproducable.

***** straight
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(progn
  (setq straight-use-package-version 'straight)
  (setq straight-use-package-by-default t)
  (setq straight-enable-package-integration t)
  (setq straight-disable-autoloads nil)
  (setq straight-cache-autoloads t)
  (setq straight-check-for-modifications nil)
  (setq straight-enable-package-integration nil)
  (setq straight-recipes-emacsmirror-use-mirror t))
#+end_src

***** customize straight directory
:PROPERTIES:
:ID: 843cc8b9-edff-42f7-a767-65a59aa38fbc
:END:

The path of the straight directory within emacs is hardcoded into
straight so we need to trick it into thinking =VOID-PACKAGES-DIR= is the
our emacs directory. This needs to be done before bootstraping
straight, else the straight directory will be created anyway. I got
this from Doom's straight branch.

#+begin_src emacs-lisp
(defun straight:use-packages-dir-a (orig-fn &rest args)
  "Use `VOID-PACKAGES-DIR' for straight directory."
  (let ((user-emacs-directory VOID-PACKAGES-DIR))
    (apply orig-fn args)))

(advice-add #'straight--emacs-dir :around #'straight:use-packages-dir-a)
#+end_src

***** bootstrap code
:PROPERTIES:
:ID: 7816be80-4db8-4219-b7d1-9a6b1ea96035
:END:

This code initializes straight if it's not already installed.

#+begin_src emacs-lisp
(defun straight:init-fn ()
  "Initialize `straight.el'."
  (defvar bootstrap-version)
  (let* ((user-emacs-directory VOID-PACKAGES-DIR)
         (bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

*** required packages
:PROPERTIES:
:ID: 453cc36d-9174-4b63-b3f2-4d1dd7e3521d
:END:

#+begin_src emacs-lisp
(straight:init-fn)

(progn
  (setq straight-use-package-version 'straight)
  (setq straight-use-package-by-default t)
  (setq straight-enable-package-integration t)
  (setq straight-disable-autoloads nil)
  (setq straight-cache-autoloads t)
  (setq straight-check-for-modifications nil)
  (setq straight-enable-package-integration nil)
  (setq straight-recipes-emacsmirror-use-mirror t))

(dolist (package '(dash general dash-functional anaphora use-package s))
  (straight-use-package package)
  (require package))
#+end_src

*** use-package
:PROPERTIES:
:ID:       b1ab4488-5793-4675-8404-b1719f804c25
:END:

Package configuration can be a monotonous and repetative process. Here, I
configure =use-package=, a declaration macro designed to provide a concise
syntax for configuring packages in a performance-oriented way.

**** wrappers
:PROPERTIES:
:ID:       1e394ffd-597f-456c-9c56-ff9de5fae017
:END:

These are wrappers around =use-package=. They serve to be consistent
with my macro naming conventions and to allow me means of customizing the
use-package syntax and arguments (as I did with [[id:3bfe8efb-bd24-47ca-90af-dd55ee950442][use-feature!]]).

***** use-package!
:PROPERTIES:
:ID:       1903deb5-bbbd-4479-81a1-c12c56d29be7
:END:

#+begin_src emacs-lisp
(defalias 'use-package! 'use-package)
#+end_src

***** use-feature!
:PROPERTIES:
:ID:       3bfe8efb-bd24-47ca-90af-dd55ee950442
:END:

This wrapper around =use-package!= is meant to explicity distinguish between
built-in packages and external packages. The idea was taken from [[https://github.com/raxod502/radian][Radian]]. The
only difference from this and =use-package!= is that straight is always nil.

#+begin_src emacs-lisp
(defmacro use-feature! (feature &rest args)
  "Wrapper around `use-package!'."
  (declare (indent defun))
  `(use-package! ,feature :straight nil ,@args))
#+end_src

**** helpers
:PROPERTIES:
:ID:       6aad4f21-9b19-44e5-8282-3aa3d7901c49
:END:

These are functions I use to help me with the configuration of =use-package=.

***** normalizing arguments
:PROPERTIES:
:ID:       31f0a13d-2175-43fe-bbce-606bbfc22fd6
:END:

****** unfold args
:PROPERTIES:
:ID:       a9ec9725-550e-4885-9292-1f937d6009f9
:END:

It's common in =use-package= to allow for arguments to be either
keyword followed by a series of arguments or a keyword followed by a list
containing the arguments. For example, =:foo 1 2 3 4= versus =:foo (1 2 3 4)=. I use
=valid-item-p= for help resolve ambigious cases, like whether ~(1 2 3 4)~ is one
argument or four.

#+begin_src emacs-lisp
(defun use-package:unfold-args (args valid-item-p)
  "Return the correct args and first invalid item from args.
Test whether every element of args is a valid.
VALID-ITEM-P is a function that takes an element as an argument and returns true
if the element is a valid element. "
  (cond ((-all-p valid-item-p args)
         (list args nil))
        ((alet (car args)
           (and (= 1 (length args))
                (not (-cons-pair-p it))
                (listp it)))
         (list (car args) (-find (-not valid-item-p) (car args))))
        (t
         (list args (-find (-not valid-item-p) args)))))
#+end_src

****** args or error
:PROPERTIES:
:ID:       58aa283e-3fb1-4483-b14f-a26aadf0231e
:END:

This function strives to be more concise than [[helpfn:use-package-as-one][use-package-as-one]] by
automatically. Also, unlike the latter, it always returns a list.

#+begin_src emacs-lisp
(defun use-package:args-or-error (key args valid-p desc)
  "Replacement for `use-package-as-one'.
DESC is the description what an individual argument should be.
VALID-P is a function that should return true is an argument is valid and false
otherwise."
  (-let (((args invalid-elt) (use-package:unfold-args args valid-p)))
    (if (not invalid-elt)
        args
      (thread-last (format "%s wants %s. Instead, %s was given" key desc invalid-elt)
        (use-package-error)))))
#+end_src

***** inserting a keyword
:PROPERTIES:
:ID:       d81b2f05-4cc5-492a-8f90-18b2f6c7214e
:END:

While [[helpfn:use-package-list-insert][use-package-list-insert]] is written in a functional style; you need to pass
in the list you want to insert into and it returns a new list with the insertion
done. But really, when am I going to use this function to insert into something
other than leaf-keywords? Using this wrapper makes adding keywords more concise.

#+begin_src emacs-lisp
(defun use-package:insert (key &optional anchor after)
  "Convenience function for inserting items into `use-package-keywords'.
This function has the side-effect of inserting KEY before ANCHOR (or after
ANCHOR if AFTER is non-nil)."
  (alet (use-package-list-insert key use-package-keywords anchor after)
    (setq use-package-keywords it)))
#+end_src

***** mode
:PROPERTIES:
:ID:       efb56015-4466-460c-ac0e-bd11906cc054
:END:

#+begin_src emacs-lisp
(defun use-package:ensure-mode (val package)
  (or val
      (alet (not (string-match-p "-mode\\'" (void-to-string package)))
        (void-symbol-intern package (when it "-mode")))))
#+end_src

***** hook
:PROPERTIES:
:ID:       8c2516d2-b747-4724-a3a4-c3b737862263
:END:

#+begin_src emacs-lisp
(defun use-package:ensure-hook (var)
  (if (string-match-p "-hook\\'" (symbol-name var))
      var
    (void-symbol-intern var "-hook")))
#+end_src

***** applying a keyword and its handler
:PROPERTIES:
:ID:       e79f67c7-d2f6-4db8-a291-156e2bbf4ebd
:END:

The purpose of this helper is to allow me to existing keywords in the body of
keywords I'm creating.

#+begin_src emacs-lisp
(defun use-package:apply-keyword (name keyword args)
  "Return the form that results from applying KEYWORD to ARGS."
  (let ((handler (void-symbol-intern 'use-package-handler/ keyword))
        (normalizer (void-symbol-intern 'use-package-normalize/ keyword)))
    (funcall handler name keyword (funcall normalizer name keyword args) nil nil)))
#+end_src

**** custom keywords
:PROPERTIES:
:ID:       7b2e899f-6fd5-45aa-91ad-464463cc229e
:END:

In this headline I define custom use-package keywords. These reflect aspects
that I feel are not covered by default =use-package= keywords.

Note that, as it says in the [[https://github.com/jwiegley/use-package][use-package README]] that defining a keyword takes
three parts inserting the keyword into [[helpvar:use-package-keywords][use-package-keywords]], defining a
normalizer, and defining a handler.

***** os
:PROPERTIES:
:ID:       e6a50f57-5f74-4d8c-8a88-17ee6b11d4c1
:END:

This keyword provides integration of [[id:1a645745-11ce-4cfb-8c5f-63470f0a61c3][with-os!]] with =use-package=. As some packages
are operating system specific, it make sense to have such a keyword for the
=use-package= declaration.

#+begin_src emacs-lisp
(use-package:insert :os :ensure)

(defun use-package-normalize/:os (name-symbol keyword args)
  (let ((message "one of the following symbols: mac, windows, linux")
        (fn (-partial #'-contains-p '(mac windows linux))))
    (use-package:args-or-error keyword args fn message)))

(defun use-package-handler/:os (name _keyword features rest state)
  (let ((body (use-package-process-keywords name rest state)))
    `((with-os! ,features ,@body))))
#+end_src

***** setting
:PROPERTIES:
:ID:       e727f35b-470b-4374-9276-3a42cce6ff28
:END:

These keywords are based on keywords in [[https://github.com/conao3/leaf.el][leaf]], an alternative to =use-package=.
They make an (I would argue) useful distinction between setting variables and
doing some non-trivial configuration in =:config= and =:init=.

****** pre-setq
:PROPERTIES:
:ID:       a4f5754e-e2f4-4d60-b675-64e92fcbe0e7
:END:

=:pre-setq= is made to set variables before a package is loaded.

#+begin_src emacs-lisp
(use-package:insert :pre-setq :init)

(defalias 'use-package-normalize/:pre-setq 'use-package-normalize/:setq)

(defun use-package-handler/:pre-setq (name _keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (mapcar (lambda (pair) `(setq ,(car pair) ,(cdr pair)))
           args)))
#+end_src

****** setq
:PROPERTIES:
:ID:       790d9f48-b670-4325-9fe2-f36631d8f1a5
:END:

=:setq= sets variables after a package is loaded.

#+begin_src emacs-lisp
(use-package:insert :setq :init)

(defun use-package-normalize/:setq (name keyword args)
  (let ((message "a cons cell whose CAR is a symbol label")
        (fn (lambda (it) (and (consp it) (symbolp (car it))))))
    (use-package:args-or-error keyword args fn message)))

(defun use-package-handler/:setq (name _keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   `((after! ,name
       ,@(mapcar (lambda (pair) `(setq ,(car pair) ,(cdr pair)))
                 args)))))
#+end_src

****** setq-default
:PROPERTIES:
:ID:       82dc8306-b3e7-4205-8472-39333a9112fd
:END:

#+begin_src emacs-lisp
(use-package:insert :setq-default :init)

(defalias 'use-package-normalize/:setq-default 'use-package-normalize/:setq)

(defun use-package-handler/:setq-default (name _keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (mapcar (lambda (pair) `(setq-default ,(car pair) ,(cdr pair)))
           args)))
#+end_src

***** defer keywords
:PROPERTIES:
:ID:       f35c631b-05e6-4c6d-bd12-40023be8efce
:END:

These keywords help improve Void startup time by deferring the loading of
packages to a later time--a time when the package is actually needed.

****** before-call
:PROPERTIES:
:ID:       ca7db9fa-1fd5-4a4e-b3bb-c0611f10c4f4
:END:

=:before-call= and its counterpart [[id:03c442ed-f497-4206-8a09-d7203083b2f2][:after-call]] let me put off package loading
until the last minute--by which I mean just before a function that needs the
package is called.

#+begin_src emacs-lisp
(use-package:insert :before-call :disabled)

(push :before-call use-package-deferring-keywords)

(defun use-package-normalize/:before-call (name keyword args)
  (use-package:args-or-error keyword args #'symbolp "a symbol"))

(defun use-package-handler/:before-call (name _keyword features rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   `((defadvice! ,(intern (format "load-%s" name)) (:before ,@features)
       (require ',name)))))
#+end_src

****** after-call
:PROPERTIES:
:ID:       03c442ed-f497-4206-8a09-d7203083b2f2
:END:

#+begin_src emacs-lisp
(use-package:insert :after-call :disabled)

(push :after-call use-package-deferring-keywords)

(defun use-package-normalize/:after-call (name keyword args)
  args)

(defun use-package-handler/:after-call (name _keyword features rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   `((defadvice! ,(intern (format "load-%s" name)) (:after ,@features)
       (require ',name)))))
#+end_src

****** idle-require
:PROPERTIES:
:ID:       7e915205-cbfc-4171-b473-4ffe2baddcc3
:END:

This keyword depends on [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]]. It allows me to specify a list of packages
to be loaded during idle time. The idea is to load dependencies of a big package
(like Org for example) so that when the time comes to load it, it will load
faster.

#+begin_src emacs-lisp
(use-package:insert :idle-require :init)

(defun use-package-normalize/:idle-require (name keyword args)
  (use-package:args-or-error keyword args #'symbolp "a symbol"))

(defun use-package-handler/:idle-require (name _keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (mapcar (lambda (feature) `(idle-require ',feature))
           (use-package-normalize-commands args))))
#+end_src

****** hook
:PROPERTIES:
:ID:       82823374-1604-4a4c-8e72-638c430df38f
:END:

Notably I overwrite the built-in definitions for the hook normalizer and
handler. I should be using overriding advice. However, when I tried to do this I
would get unusual problems.

#+begin_src emacs-lisp
(defun use-package-normalize/:hook (name keyword args)
  (thread-last "a symbol or cons cell"
    (use-package:args-or-error keyword args (-orfn #'symbolp #'-cons-pair-p))
    (--map-when (not (-cons-pair-p it)) (cons it nil))
    (--map (cons (use-package:ensure-hook (car it))
                 (use-package:ensure-mode (cdr it) name)))))

(defun use-package-handler/:hook (name keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (mapcar (-lambda ((hook . fn)) `(void-add-hook ',hook #',fn))
           (use-package-normalize-commands args))))
#+end_src

***** alias
:PROPERTIES:
:ID:       3168a5c8-0534-42e7-82b7-ed33bcb99ff6
:END:

Many times I need to define aliases.

#+begin_src emacs-lisp
(use-package:insert :alias :init)

(defun use-package-normalize/:alias (name keyword args)
  (let ((message "a cons cell"))
    (use-package:args-or-error keyword args #'-cons-pair-p message)))

(defun use-package-handler/:alias (name _keyword args rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (mapcar (-lambda ((alias . def)) `(defalias ',alias ',def))
           (use-package-normalize-commands args))))
#+end_src

***** popup
:PROPERTIES:
:ID:       bdd0f442-4351-4ac8-874b-33991b6c2806
:END:

Many packages have their own buffers they like to open.

#+begin_src emacs-lisp
(use-package:insert :popup :init)

(defun use-package-normalize/:popup (name keyword args)
  (use-package:args-or-error keyword args #'list "a list"))

(defun use-package-handler/:popup (name _keyword args rest state)
  (--map `(push ',it display-buffer-alist) args))
#+end_src

***** advice
:PROPERTIES:
:ID:       a7ac6b87-62d3-416e-bc0a-26072bcf3bf8
:END:

The advice keyword allows for a quick and convenient adding of advice.

#+begin_src emacs-lisp
(use-package:insert :advice :hook)

(defun use-package-normalize/:advice (name keyword args)
  (if (and (listp (car args))
           (-all-p (-orfn #'symbolp #'-cons-pair-p) (cdr args)))
      (cons (car args)
            (--map-when (not (-cons-pair-p it))
                        (cons it nil)
                        (cdr args)))
    (use-package-error "should be a keyword followed by")))

(defun use-package-handler/:advice (name _keyword args rest state)
  (-let* (((where . advices) (car args)))
    (use-package-concat
     (use-package-process-keywords name rest state)
     (-map (-lambda ((fn . advice)) `(void-add-advice #',fn ,where #',advice))
           advices)
     (use-package:apply-keyword name :commands (-map #'cdr advices)))))

(push :advice use-package-deferring-keywords)
#+end_src

***** TODO trigger
:PROPERTIES:
:ID:       0a3580f4-42a3-4b17-807b-366611d6f90a
:END:

The trigger the loading of specific dependencies for a package.

#+begin_src emacs-lisp
(use-package:insert :trigger :commands t)

(defun use-package-normalize/:trigger (name keyword args)
  (use-package:args-or-error keyword args #'symbolp "a symbol"))

(defun use-package-handler/:trigger (name _keyword features rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (if (plist-get state :commands)
       (--map `(defadvice! ,(intern (format "load-%s-for-%s" it name)) (:before ,it)
                 (require ',it))
              args)
     `((after! ,name
         (void-log "Loading needed libraries for name.")
         (-map #'require '()))))))
#+end_src

***** TODO system ensure keyword
:PROPERTIES:
:ID:       6fb147bd-157a-40e4-90bd-f6f173598f60
:END:

As is the ensure keyword that comes with use-package is too coarse.

#+begin_src emacs-lisp
(use-package:insert :trigger :commands t)

(defun use-package-normalize/:trigger (name keyword args)
  (use-package:args-or-error keyword args #'symbolp "a symbol"))

(defun use-package-handler/:trigger (name _keyword features rest state)
  (use-package-concat
   (use-package-process-keywords name rest state)
   (if (plist-get state :commands)
       (--map `(defadvice! ,(intern (format "load-%s-for-%s" it name)) (:before ,it)
                 (require ',it))
              args)
     `((after! ,name
         (void-log "Loading needed libraries for name.")
         (-map #'require '()))))))
#+end_src

**** boostrap
:PROPERTIES:
:ID:       90cc0147-85eb-4d5a-a555-8699faf5a29e
:END:

What better way to start =use-package= than by using it to configure itself?! I
set [[helpvar:use-package-always-ensure][use-package-always-ensure]] to nil because straight handles that. =:demand t=
isn't necessary here because =use-package= is a required package. However, having
it drives the point home that this package is loaded during initialization.

#+begin_src emacs-lisp
(use-package! use-package
  :demand t
  :pre-setq
  (use-package-ignore-unknown-keywords . t)
  (use-package-always-defer . t)
  (use-package-always-ensure . nil)
  (use-package-verbose . nil)
  (use-package-expand-minimally . t))

;; ensure system package is a feature of `use-package' that integrates with
;; `system-packages' to ensure a package has its required system packages
;; installed.
(use-package! use-package-ensure-system-package
  :demand t)
#+end_src

** Library
:PROPERTIES:
:ID: 3e9e5e7a-9f9b-4e92-b569-b5e8ba93820f
:END:

This headline contains all the the helper functions and macros I defined for
customizing emacs.

*** org ml
:PROPERTIES:
:ID:       8bac9361-2c29-4e17-b6e2-10ec679a5e24
:END:

[[][org ml]] is a functional library for programmatically generating org mode
structures. It was built for.

#+begin_src emacs-lisp
(use-package! org-ml)
#+end_src

*** ts
:PROPERTIES:
:ID:       64d19467-a878-449c-8402-88892c25ac9a
:END:

=ts= is a time package.

#+begin_src emacs-lisp
(use-package! ts)
#+end_src

*** macro writing tools
:PROPERTIES:
:ID:       ea5d3295-d8f9-4f3a-a1f6-25811696aa29
:END:

**** get keywords arguments in macro
:PROPERTIES:
:ID:       dc7a63e6-041b-4855-b206-6d72ef732de1
:END:

Following past examples (such as), I initially opted for allowing keyword
arguments in the "function args" part of defun-like macros. This is fine when
there's only one keyword argument, but any more and it starts to get crowded. It
doesn't help that emacs functions tend towards longer names due to a lack of
namespaces. Therefore, I support keyword args in the function body.

#+begin_src emacs-lisp
(defun void--keyword-macro-args (body)
  "Return list of (docstring KEYWORD-ARGS BODY)."
  (list (when (stringp (car body)) (pop body))
        (--unfold (when (keywordp (car it))
                    (cons (cons (pop body) (pop body))
                          body))
                  body)
        body))
#+end_src

**** format macro
:PROPERTIES:
:ID:       c2f43f84-e400-45ed-9e96-7b8d38133810
:END:

The purpose of this macro is to fascillitate the creating of cut paste keywords
so often used in macros. Let me explain. Often you want a macro to be a
"front-end" so-to-speak for defining functions and variables that usually follow
a naming scheme. In the macro body we end up with many ~(intern (format
"foo-%s-baz" var))~ forms. This macro allows you to write this as ~foo-<var>-baz~
instead.

***** convert a keyword into its equivalent
:PROPERTIES:
:ID:       aa083f01-a4de-4ce8-bbcc-7f493adad227
:END:

#+begin_src emacs-lisp
(defun void--anaphoric-format (symbol)
  "Return the form that will replace."
  (if-let ((regexp VOID-ANAPHORIC-SYMBOL-REGEXP)
           (string (and (symbolp symbol) (symbol-name symbol)))
           (symbols (--map (nth 1 it) (s-match-strings-all regexp string)))
           (format-string (s-replace-regexp regexp "%s" string)))
      `(,'\, (intern (format ,format-string ,@(-map #'intern symbols))))
    symbol))
#+end_src

***** defmacro!
:PROPERTIES:
:ID:       7cd61cb8-22be-460d-b4f4-da6c82435958
:END:

#+begin_src emacs-lisp
(defmacro defmacro! (name args &rest body)
  "Like `defmacro' but allows for anaphoric formatting."
  (-let [(docstring _ body) (void--keyword-macro-args body)]
    `(defmacro ,name ,args
       ,docstring
       ,@(-tree-map #'void--anaphoric-format body))))
#+end_src

**** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

***** symbol intern
:PROPERTIES:
:ID: 659e8389-84c5-4ac4-a9ba-7dd40599191d
:END:

#+begin_src emacs-lisp
(defun void-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'void-to-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID: f2668044-13b2-46e7-bf84-fcf998591e37
:END:

#+begin_src emacs-lisp
(defun void-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'void-symbol-intern ":" args))
#+end_src

***** keyword name
:PROPERTIES:
:ID: fb867938-d62b-42fc-bf07-092f10b64f22
:END:

#+begin_src emacs-lisp
(defun void-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (void-to-string keyword) 1))
#+end_src

***** convert to string
:PROPERTIES:
:ID: 4ef52875-4ce6-4940-8b7e-13c96bedcb3d
:END:

#+begin_src emacs-lisp
(defun void-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (dolist (a args) (princ a))))
#+end_src

**** wrap-form
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

#+begin_src emacs-lisp
(defun void-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (void-wrap-form (cdr wrappers)
                      (append (car wrappers)
                              (list form)))
    form))
#+end_src

**** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

***** anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst VOID-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (1+ (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

***** anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p VOID-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

***** true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match VOID-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

***** body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
    (-filter #'void-anaphoric-symbol-p)
    (-uniq)))
#+end_src

***** all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all VOID-ANAPHORIC-SYMBOL-REGEXP (void-to-string obj)))
#+end_src

**** with-symbols!
:PROPERTIES:
:ID:       0ba70f30-f1a8-4a5d-acf9-07db9931bd54
:END:

#+begin_src emacs-lisp
(defmacro with-symbols! (names &rest body)
  "Bind each variable in NAMES to a unique symbol and evaluate BODY."
  (declare (indent defun))
  `(let ,(-map (lambda (symbol) `(,symbol (make-symbol ,(symbol-name symbol)))) names)
     ,@body))
#+end_src

**** once-only!
:PROPERTIES:
:ID:       23c10e2a-6ccc-42dc-a898-29ab39a1f79c
:END:

#+begin_src emacs-lisp
(defmacro once-only! (bindings &rest body)
  "Rebind symbols according to BINDINGS and evaluate BODY.

Each of BINDINGS must be either a symbol naming the variable to be
rebound or of the form:

  (SYMBOL INITFORM)

where INITFORM is guaranteed to be evaluated only once.

Bare symbols in BINDINGS are equivalent to:

  (SYMBOL SYMBOL)"
  (declare (indent defun))
  (let* ((bind-fn (lambda (bind)
                    (if (consp bind)
                        (cons (car bind) (cadr bind))
                      (cons bind bind))))
         (names-and-forms (-map bind-fn bindings))
         (names (-map #'car names-and-forms))
         (forms (-map #'cdr names-and-forms))
         (symbols (--map (make-symbol (symbol-name it)) names)))
    `(with-symbols! ,symbols
       (list 'let
             (-zip-with #'list (list ,@symbols) (list ,@forms))
             ,(cl-list* 'let
                        (-zip-with #'list names symbols)
                        body)))))
#+end_src

*** hooks
:PROPERTIES:
:ID:       a9fb6a01-ded5-405c-83ba-c401dbc06400
:END:

One of the most common ways to customize Emacs is via [[info:elisp#Hooks][hooks]]. Hooks are variables
containing functions (also referred to as hooks). The functions in hooks are run
after certain events, such as starting and quitting emacs. Their purpose is to
fascillitate customization of what happens before or after particular events.

In this headline, I strive to establish a common naming convention for
Void-defined hooks, so I can clearly distinguish them from pre-defined hooks.

**** hook-p
:PROPERTIES:
:ID:       1995a309-e1d3-40e5-b6b1-fbcd81dda0bb
:END:

#+begin_src emacs-lisp
(defun void-hook-p (fn)
  "Return non-nil if FN is a Void hook."
  (s-matches-p "\\`[^[:space:]]+&[^[:space:]]+\\'"
               (symbol-name fn)))
#+end_src

**** hook variable
:PROPERTIES:
:ID:       77f45347-3688-438d-8674-39e6d476a2d1
:END:

A useful consequence of the hook naming convention is I can determine precisely
which hook variable a function resides in based on looking at the name
(=emacs-startup-hook&do-something= would be a hook in =emacs-starup-hook= for
example). This proves to be useful for [[id:8506fa78-c781-4ca8-bd58-169cce23a504][expire advice]].

#+begin_src emacs-lisp
(defun void-hook-var (hook-fn)
  "Return the hook variable HOOK-FN is in.
HOOK-FN is a function named with Void naming conventions."
  (->> (symbol-name hook-fn)
       (s-match (rx (group (1+ anything)) "&"))
       (nth 1)
       (intern)))
#+end_src

**** hook name
:PROPERTIES:
:ID:       6b14ea72-b8ef-493d-82e2-962f889736a2
:END:

This function is to help produce names that abide by hook naming conventions.

#+begin_src emacs-lisp
(defun void-hook-name (var hook)
  "Return a hook name that meets Void naming conventions."
  (funcall (-partial #'void-symbol-intern var '&)
           (or (->> (symbol-name hook)
                    (s-match "void--\\([^[:space:]]+\\)-hook")
                    (nth 1))
               hook)))
#+end_src

**** hook action
:PROPERTIES:
:ID:       fa705f26-31f0-43c3-80a6-6741e74ab0ea
:END:

#+begin_src emacs-lisp
(defun void-hook-action (hook)
  "Return the action for hook."
  (->> (symbol-name hook)
       (s-match (rx "&" (group (1+ (not (any "&" white)))) eos))
       (nth 1)))
#+end_src

**** adding hooks
:PROPERTIES:
:ID:       aaf7ab9a-0648-4f1b-b30e-85ce0acac602
:END:

Add a hook that follow naming conventions. When adding a hook, if it is a void
function, change it to a hook.

#+begin_src emacs-lisp
(defun void-add-hook (var hook &optional depth local expire-fn)
  "Alias HOOK to match Void naming conventions and add it to VAR.
If EXPIRE-FN"
  (let* ((new-hook (void-hook-name var hook))
         (hook-log (void-symbol-intern new-hook '@ 'log-on-debug)))
    (defalias new-hook hook)
    (add-hook var new-hook depth local)
    (fset hook-log
          `(lambda (&rest _)
             (alet ,(void-hook-action new-hook)
               (void-log "& %s -> %s" ',var it))))
    (advice-add new-hook :before hook-log)
    (when expire-fn
      (->> (void-expire-advice hook expire-fn t)
           (advice-add new-hook :around)))))
#+end_src

**** defhook!
:PROPERTIES:
:ID:       4daf2baf-ea7f-41f5-9f86-63168089149a
:END:

=defhook= provides a declarative way declare hook functions. It uses a familiar
defun-like syntax.

#+begin_src emacs-lisp
(defmacro! defhook! (name args &rest body)
  "Define a hook function and attatch it to HOOK and HOOKS.
DEPTH and LOCAL are the same as in `add-hook'. BODY is the body of the hook
function.

\(NAME (HOOK &REST HOOKS &OPTIONAL DEPTH LOCAL) &rest BODY)"
  (declare (doc-string 3))
  (-let* ((hooks (-take-while (-not #'keywordp) args))
          (local (plist-get hooks :local))
          (depth (or (plist-get hooks :append) (plist-get hooks :depth)))
          ((docstring _ body) (void--keyword-macro-args body)))
    `(progn
       ,@(-map (lambda (hook)
                 `(aprog1 (defun void--<name>-hook (&rest _) ,docstring
                                 ,@body)
                    (void-add-hook ',hook it ,depth ,local)))
               hooks))))
#+end_src

*** advice
:PROPERTIES:
:ID:       19b9021d-f310-485b-9258-4df19423c082
:END:

[[info:elisp#Advising Functions][Advising]] is one of the most powerful ways to customize emacs's behavior. In this
headline I provide a macro to concisely define functions that are specifically
intended to advise other functions and to ensure that these functions are named
properly. All user-defined advising functions should have the format
=TARGET@ACTION=, where =TARGET= is the function being advised and =ACTION= is the
action the advise is performing. This naming scheme is inspired and taken from
the one introduced by [[helpfn:define-advice][define-advice]].

**** advice-p
:PROPERTIES:
:ID:       0a84d983-39ad-48d1-af9d-b43589d63bcf
:END:

This function should be used to distinguish advices I add to functions over
advices that have been added by Emacs or other packages.

#+begin_src emacs-lisp
(defun void-advice-p (fn)
  "Return non-nil if FN is a void advice."
  (s-matches-p (rx (1+ (not white)) "@" (1+ (not white)))
               (symbol-name fn)))
#+end_src

**** advised function
:PROPERTIES:
:ID:       f893fbe8-592b-409e-8de7-6060e936456f
:END:

It's easy to find which functions are advising a given function using
[[helpfn:advice-mapc][advice-mapc]]. However, it's not as easy to go the other way around--to determine
what which function a given advice is advising. Another complicaiton is that
it's possible for a given advice to advise multiple functions. With the naming
system I provide, doing this is trivial.

#+begin_src emacs-lisp
(defun void-advised-fn (fn)
  "Return the function advised by FN.
ADVICE is an advice of the form \"advisee@advisor\", where this function returns
\"advisee\"."
  (->> (symbol-name advice)
       (s-match (rx (group (1+ (not white))) "@" (1+ (not white))))
       (nth 1)
       (intern)))
#+end_src

**** advice name
:PROPERTIES:
:ID:       03416f82-ced7-42a0-843b-6975903f0b38
:END:

#+begin_src emacs-lisp
(defun void-advice-name (fn advice)
  "Return advice name that meets Void naming conventions.
Advice name is of the form FN@ADVICE."
  (funcall (-partial #'void-symbol-intern fn '@)
           (or (->> (symbol-name advice)
                    (s-match "void--\\([^[:space:]]+\\)-advice")
                    (nth 1))
               advice)))
#+end_src

**** adding advice
:PROPERTIES:
:ID:       4750f4dc-053b-4062-bd6c-aeeed6cdbcd9
:END:

Often, I advise functions with other existing functions (such as =#'ignore=)
instead of defining my own advices. To maintain consistency with the naming
convention I created [[helpfn:void-add-advice][void-add-advice]]. It will create an advice with an
appropriate name to target.

#+begin_src emacs-lisp
(defun void-add-advice (target where advice &optional props expire-fn)
  "Advise TARGETS with Void ADVICES.
This function generates a new."
  (let* ((new-advice (void-advice-name target advice))
         (log-advice (void-symbol-intern new-advice '@ 'log-on-debug)))
    (defalias new-advice advice)
    (advice-add target where new-advice props)
    (fset log-advice
          `(lambda (&rest _)
             (alet ,(void-advice-action new-advice)
               (void-log "@ %s -%s-> %s" #',target ,where it))))
    (advice-add new-advice :before log-advice)
    (when expire-fn
      (->> (void-expire-advice target expire-fn)
           (advice-add new-advice :around)))))
#+end_src

**** advice action
:PROPERTIES:
:ID:       f15279e9-cd0c-4a74-bc74-389d14a4b82a
:END:

#+begin_src emacs-lisp
(defun void-advice-action (advice)
  "Return the action for advice."
  (->> (symbol-name advice)
       (s-match (rx "@" (group (1+ (not (any "@" white)))) eos))
       (nth 1)))
#+end_src

**** expire advice
:PROPERTIES:
:ID:       8506fa78-c781-4ca8-bd58-169cce23a504
:END:

Often there are functions you want to advise just once. For example, loading a
feature just before a function that needs it is called. Although it's harmless,
you don't want to keep reloading the feature everytime the function is called.
The way I handle this situation is by creating a function that generates an
=expire-advice=. When an =expire-advice= it will.

Note that this function returns must be evaluated with lexical binding to work.

#+begin_src emacs-lisp
(defun void-expire-advice (fn &optional expire-fn unbind)
  "Return an advice that causes FN to expire when EXPIRE-FN returns true.
FN is a function. EXPIRE-FN is a function that returns true when FN
should expire."
  (let ((expire-advice (void-advice-name fn 'expire))
        (expire-fn (or expire-fn (lambda () t))))
    (fset expire-advice
          (lambda (orig-fn &rest args)
            (aprog1 (apply orig-fn args)
              (when (funcall expire-fn)
                (when (void-advice-p fn)
                  (advice-remove (void-advisee fn) fn))
                (when (void-hook-p target)
                  (remove-hook (void-hook-var FN)))
                (advice-remove target expire-advice)
                (fmakunbound expire-advice)
                (void-log "%s has expired." target)
                (when unbind
                  (fmakunbound target))))))
    expire-advice))
#+end_src

**** defadvice!
:PROPERTIES:
:ID:       1e0f3a27-a7d8-4e28-a359-f42ed7a16033
:END:

This section pertains to [[helpfn:defadvice!][defadvice!]], a replacement for [[helpfn:define-advice][define-advice]] that
provides a declarative way to define advices.

***** define-advice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

The only difference between this and [[helpfn:define-advice][define-advice]] is that =NAME= and =SYMBOL= are
switched. In my opinion, the unique part of the function name being first is
more consistent with =defun=.

#+begin_src emacs-lisp
(defmacro! define-advice! (name args &rest body)
  "A wrapper around `define-advice'.
The only difference is that this switches the order the arguments have to be
passed in.

\(fn ACTION (WHERE &optional ADVICE-ARGS TARGET &rest TARGETS) &rest BODY)"
  (declare (indent 2) (doc-string 3) (debug (sexp sexp body)))
  (unless (listp args)
    (signal 'wrong-type-argument (list #'listp args)))
  (-let (((where lambda-args fn props) args))
    `(aprog1 (defun void--<name>-advice ,lambda-args
               ,@body)
       (void-add-advice #',fn ,where it ,props))))
#+end_src

***** anaphoric defadvice!
:PROPERTIES:
:ID:       98b2ce63-da31-4f7a-b776-1ee1747b5d57
:END:

=anaphoric-define-advice!= lets you omit the =lambda-args=. If you do omit the
arguments and you want to use them, you can do so via [[id:9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df][anaphoric variables]].

#+begin_src emacs-lisp
(defmacro anaphoric-define-advice! (name args &rest body)
  "A variant of `define-advice!'.
Unlike `define-advice!', this macro does not take an arglist as an argument.
Instead, arguments are accessed via anaphoric variables.

\(fn ACTION (WHERE TARGET &rest TARGETS) &rest BODY)"
  (-let* (((where target . other-args) args)
          (advice-args (if (eq where :around)
                           '(<orig-fn> &rest <args>)
                         '(&rest <args>))))
    `(define-advice! ,name (,where ,advice-args ,target ,@other-args)
       (ignore <args>)
       (cl-progv (->> (help-function-arglist #',target t)
                      (--remove (s-starts-with-p "@" (symbol-name it)))
                      (--map (intern (format "<%s>" (symbol-name it)))))
           <args>
         ,@body))))
#+end_src

***** defadvice!
:PROPERTIES:
:ID:       d8773e00-1abe-4b03-82f0-07b47e93ccb4
:END:

This macro takes care of allowing multiple advices and deciding between whether
to use =defadvice!= or =anaphoric-defadvice!=.

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Define and advice.

\(fn ACTION (WHERE &optional ARGS-LIST TARGET &rest TARGETS) &rest BODY)"
  (-let* ((symbols-only (lambda (it) (and (symbolp it) (not (keywordp it)))))
          ((before fns after) (-partition-by symbols-only args))
          (advice-macro (if (listp (nth 1 args))
                            'define-advice!
                          'anaphoric-define-advice!)))
    `(progn
       ,@(--map `(,advice-macro ,name (,@before ,it ,@after) ,@body)
                fns))))
#+end_src

*** deferred loading
:PROPERTIES:
:ID:       1d0746ea-ecb2-46ad-8afa-a54aca74a185
:END:

**** with-os!
:PROPERTIES:
:ID: 1a645745-11ce-4cfb-8c5f-63470f0a61c3
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows'(unquoted)."
  (declare (indent defun))
  (setq os (if (listp os) os (list os)))
  (when (funcall (cond ((eq :not (car-safe os)) (lambda (a b) (not (member a b))))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 os)
    `(progn ,@body)))
#+end_src

**** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

If an =eval-after-load= block contains an error and it is triggered by a
feature, the error will keep raised everytime you load that feature.

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  ""
  (declare (indent defun))
  `(eval-after-load ',feature
     '(with-no-warnings
        (condition-case error
            (progn ,@body)
          (error
           (message "Error: %S" error)
           (message "BODY: %S" ',body))))))
#+end_src

**** after!
:PROPERTIES:
:ID: b31cd42d-cc57-492d-afae-d7d5e353e931
:END:

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from polluting the
[[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to =after-load-list= whether or not it has
been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Same as `with-eval-after-load' but."
  (declare (indent defun) (debug t))
  (pcase (car-safe features)
    ('or
     (macroexp-progn
      (--map `(after! ,it ,@body) (cdr features))))
    ('and
     (void-wrap-form (--map `(after! ,it) (cdr features))
                     (macroexp-progn body)))
    ((guard (listp features))
     `(after! ,(cons 'and features) ,@body))
    ((pred symbolp)
     `(if (featurep ',features)
          ,(macroexp-progn body)
        (eval-after-load! ,features ,@body)))
    (_ (error "Invalid argument."))))
#+end_src

*** macros
:PROPERTIES:
:ID:       f27aa611-a2bd-4b76-85ce-72feb1e9f19f
:END:

**** ignore!
:PROPERTIES:
:ID: 0597956f-d40c-4c2b-9adf-5ece8c5b38de
:END:

#+begin_src emacs-lisp
(defmacro ignore! (&rest _)
  "Do nothing and return nil."
  nil)
#+end_src

**** anaphoric macros
:PROPERTIES:
:ID:       001dde5a-bb43-4ce8-82ef-806e37ba7f6e
:END:

***** pair value extraction
:PROPERTIES:
:ID: e546a63f-eb75-4b72-9392-2a6041f87f50
:END:

When extracting one value from a plist, alist or another lisp data structure at
a time, it often suffices to use =plist-get=, =alist-get= or whatever function
is used to get a particular value based on the structure. Sometimes, however, we
need to get and use many values from the data structure. And in these cases it
becomes repetative to have to do ~(plist-get plist key)~ all the time.

****** with-structure!
:PROPERTIES:
:ID: c88dac35-9345-49f5-bdb5-e856071e6764
:END:

#+begin_src emacs-lisp
(defmacro with-structure! (structure fn &rest body)
  "Access items from STRUCTURE.
FN is a function that accepts two arguments, the structure and a symbol name. FN
should return the value of structure for that symbol.
BODY contains any number of `<NAME>' where NAME refers to the name of the symbol."
  (declare (indent 2))
  (let* ((symbols (->> (flatten-list body)
                       (-filter #'void-anaphoric-symbol-p)
                       (-uniq)))
         (names (-map #'void-anaphoric-true-symbol symbols))
         (structure-sym (make-symbol "structure")))
    `(let* ((,structure-sym ,structure)
            ,@(--map `(,it (funcall ,fn ,structure-sym ',it))
                     (-zip #'list symbols names)))
       ,@body)))
#+end_src

****** with-plist!
:PROPERTIES:
:ID: f84e30a9-b725-415e-b1df-7b4489913d2c
:END:

#+begin_src emacs-lisp
(defmacro with-plist! (plist &rest body)
  (declare (indent 1))
  `(with-structure! ,plist #'plist-get ,@body))
#+end_src

****** with-alist!
:PROPERTIES:
:ID: d594c666-0ec1-4c72-9159-5ddea9702d03
:END:

#+begin_src emacs-lisp
(defmacro with-alist! (alist &rest body)
  (declare (indent 1))
  `(with-structure! ,alist (lambda (key) (alist-get key alist)) ,@body))
#+end_src

**** list mutation
:PROPERTIES:
:ID:       d9f77404-5c29-4305-ae53-e409e1b06b99
:END:

***** append!
:PROPERTIES:
:ID: f314672c-f9f3-4630-9402-a9a65215c153
:END:

#+begin_src emacs-lisp
(defmacro append! (sym &rest lists)
  "Append LISTS to SYM.
SYM is a symbol that stores a list."
  (declare (indent 1))
  `(setq ,sym (append ,sym ,@lists)))
#+end_src

***** prepend!
:PROPERTIES:
:ID: 3395dec3-0915-49cd-9445-d3db2b1ffe7f
:END:

#+begin_src emacs-lisp
(defmacro prepend! (sym &rest lists)
  (declare (indent defun))
  `(setq ,sym (append ,@lists ,sym)))
#+end_src

***** nconc!
:PROPERTIES:
:ID: b24d1d8f-f3e1-4dca-afdb-8fb73d5299c3
:END:

#+begin_src emacs-lisp
(defmacro nconc! (sym &rest lists)
  "Append LISTS to SYM by altering them in place."
  (declare (indent 1))
  `(setq ,sym (nconc ,sym ,@lists)))
#+end_src

** Packages
:PROPERTIES:
:ID:       d5c0d112-319d-4271-a819-eb786a64bfc6
:END:

*** print output when installing a package
:PROPERTIES:
:ID:       428aa579-bbd6-4169-9bca-8da581e0b81d
:END:

For debugging reasons, it's nice to know when a package was successfully
installed or not. Therefore, I advise straight to log this information for me.

#+begin_src emacs-lisp
(defadvice! print-output-on-debug (:around straight-use-package)
  "Log whether package is intalled or not if `void-debug-p' is non-nil."
  (alet (or (car-safe (car <args>)) (car <args>))
    (if (called-interactively-p)
        (apply <orig-fn> <args>)
      (condition-case err
          (progn (apply <orig-fn> <args>)
                 (void-log "✓ installed %s" it))
        (error
         (void-log "✕ failed to install %s because of %s" it err))))))
#+end_src

*** built-in
:PROPERTIES:
:ID: 40367976-12a0-4ccd-9aff-4df144a73edf
:END:

**** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-feature! vc-hooks
  :setq
  (vc-follow-link . t)
  (vc-follow-symlinks . t))
#+end_src

**** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-feature! subr-x
  :demand t)
#+end_src

**** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:END:

Emacs starts up with a default screen. Note that it doesn't seem this feature is
provided (perhaps it's too fundamental?), therefore I use =:pre-setq=.

#+begin_src emacs-lisp
(use-feature! startup
  :pre-setq
  (inhibit-startup-screen . t)
  (inhibit-default-init . t)
  (inhibit-startup-buffer-menu . t)
  (initial-major-mode . 'fundamental-mode)
  (initial-scratch-message . nil)
  (initial-buffer-choice . #'void-initial-buffer)
  (inhibit-startup-echo-area-message . user-login-name))
#+end_src

**** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:END:

#+begin_src emacs-lisp
(use-package! paren
  :hook (prog-mode-hook . show-paren-mode)
  :setq-default
  (show-paren-delay . 0))
#+end_src

**** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:END:

#+begin_src emacs-lisp
;; Not windows.
(use-feature! select
  :setq
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary . t)
  (x-select-request-type . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

**** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:END:

#+begin_src emacs-lisp
(use-feature! simple
  :popup ("\\*Messages"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :setq-default
  (idle-update-delay . 1)
  (blink-matching-paren . t)
  (delete-trailing-lines . nil)
  :setq
  (mail-user-agent . 'mu4e-user-agent))
#+end_src

**** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(use-feature! loaddefs
  :setq-default
  (disabled-command-function . nil)
  ;; very important if you're using msmtp
  )
#+end_src

**** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:END:

#+begin_src emacs-lisp
(use-feature! files
  :setq-default
  ;; Disable second, case-insensitive pass over `auto-mode-alist'.
  (auto-mode-case-fold . nil)
  ;; Whether to add a newline automatically at the end of the file.
  ;; Whether confirmation is requested before visiting a new file or buffer.
  (confirm-nonexistent-file-or-buffer . nil)
  ;; How to ask for confirmation when leaving Emacs.
  (confirm-kill-emacs . #'y-or-n-p)
  (require-final-newline . nil)
  (trash-directory . (expand-file-name "Trash" "~"))
  (auto-save-default . nil)
  (auto-save-interval . 300)
  (auto-save-timeout . 30)
  (backup-directory-alist . (list (cons ".*" (concat VOID-DATA-DIR "backup/"))))
  (make-backup-files . nil)
  (version-control . nil)
  (kept-old-versions . 2)
  (kept-new-versions . 2)
  (delete-old-versions . t)
  (backup-by-copying . t)
  (backup-by-copying-when-linked . t))
#+end_src

**** subr
:PROPERTIES:
:ID:       61603f44-780e-4456-88c6-7ffe1e5c7197
:END:

#+begin_src emacs-lisp
(use-feature! subr
  :init
  (fset #'yes-or-no-p #'y-or-n-p)
  (fset #'display-startup-echo-area-message #'ignore))
#+end_src

**** subr-x
:PROPERTIES:
:ID:       1ed0ba00-e5a1-4642-9ed5-a52f4b917a4d
:END:

#+begin_src emacs-lisp
;; This is where `->>' and `thread-first' come from.
(use-feature! subr-x
  :demand t)
#+end_src

**** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-feature! ffap
  :setq
  (ffap-machine-p-known . 'reject))
#+end_src

**** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(use-feature! server
  :setq
  (server-auth-dir . (concat VOID-DATA-DIR "server/")))
#+end_src

**** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:END:

#+begin_src emacs-lisp
(use-feature! tramp
  :setq
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-auto-save-directory . (concat VOID-DATA-DIR "tramp-auto-save/"))
  (tramp-persistency-file-name . (concat VOID-DATA-DIR "tramp-persistency.el")))
#+end_src

**** desktop
:PROPERTIES:
:ID: 3a6b72e7-57c8-42f0-a8d7-1bbde72de9bd
:END:

#+begin_src emacs-lisp
(use-feature! desktop
  :setq
  (desktop-dirname . (concat VOID-DATA-DIR "desktop"))
  (desktop-base-file-name . "autosave")
  (desktop-base-lock-name . "autosave-lock"))
#+end_src

**** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(use-feature! cus-edit
  :setq
  (custom-file . (concat VOID-DATA-DIR "custom.el"))
  (custom-theme-directory . (concat VOID-LOCAL-DIR "themes/")))
#+end_src

**** url cache
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(use-feature! url
  :setq
  (url-cache-directory . (concat VOID-DATA-DIR "url/cache/"))
  (url-configuration-directory . (concat VOID-DATA-DIR "url/configuration/")))
#+end_src

**** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-feature! bytecomp
  :setq
  (byte-compile-verbose . void-debug-p)
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local)))
#+end_src

**** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-feature! compile
  :setq-default
  (compilation-always-kill . t)
  (compilation-ask-about-save . nil)
  (compilation-scroll-output . 'first-error))
#+end_src

**** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-feature! uniquify
  :setq-default
  (uniquify-buffer-name-style . 'forward))
#+end_src

**** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-feature! ansi-color
  :setq-default
  (ansi-color-for-comint-mode . t))
#+end_src

**** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

#+begin_src emacs-lisp
(use-feature! image-mode
  :setq
  ;; Non-nil means animated images loop forever, rather than playing once.
  (image-animate-loop . t))
#+end_src

**** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-feature! window
  :setq-default
  (split-width-threshold . 160))
#+end_src

**** paragraphs
:PROPERTIES:
:ID:       f289ade4-ad16-4f6a-8868-1f9b7af5ddca
:END:

#+begin_src emacs-lisp
(use-feature! paragraphs)
#+end_src

**** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-feature! indent
  :setq-default
  (tab-always-indent . t))
#+end_src

**** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-feature! mouse
  :setq-default
  (mouse-yank-at-point . t))
#+end_src

**** calendar
:PROPERTIES:
:ID:       4ad7e704-f490-40e4-b2bc-8a30a10a7bb7
:END:

#+begin_src emacs-lisp
(use-feature! calendar
  :setq (diary-file . (concat VOID-DATA-DIR "diary")))
#+end_src

**** mule-cmds
:PROPERTIES:
:ID:       e48e925e-1f1e-4c79-8652-c92aafe06290
:END:

#+begin_src emacs-lisp
(use-feature! mule-cmds
  :init (prefer-coding-system VOID-DEFAULT-CODING-SYSTEM))
#+end_src

**** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-feature! gv
  :config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

**** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-feature! nsm
  :setq (nsm-settings-file . (concat VOID-DATA-DIR "network-settings.data")))
#+end_src

*** external libraries
:PROPERTIES:
:ID: 6e4be80e-8149-424d-a801-d7871bfe8fc8
:END:

**** dash

Dash is an excellent functional list manipulation library. If I did not use it
as a dependency, I'd end up rewriting many of its functions.

:PROPERTIES:
:ID:       7d37ae8b-d319-4077-ae7a-aa463d8ec68d
:END:

#+begin_src emacs-lisp
(use-package! dash
  :demand t)
#+end_src

**** dash-functional
:PROPERTIES:
:ID:       4be107b5-b756-4372-9f74-655bda941b75
:END:

#+begin_src emacs-lisp
(use-package! dash-functional
  :demand t)
#+end_src

**** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:END:

***** general
:PROPERTIES:
:ID: f1ad5258-17cb-4424-a161-b856ee6dc5ab
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. It would be nice to have one keybinding function that can
handle all bindings. [[][general]] provides such a function ([[helpfn:general-define-key][general-define-key]]).

#+begin_src emacs-lisp
(use-package! general
  :demand t
  :config
  (general-auto-unbind-keys))
#+end_src

***** prefix bindings
:PROPERTIES:
:ID: b0b5b51c-155e-46fc-a80a-0d45a32440ba
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion. [[][spacemacs]].

****** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defvar void-leader-key "SPC"
  "The evil leader prefix key.")

(defvar void-leader-alt-key "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

****** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defvar void-localleader-key "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void-localleader-alt-key "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void-localleader-short-key ","
  "A shorter alternative `void-localleader-key'.")

(defvar void-localleader-short-alt-key "M-,"
  "A short non-normal  `void-localleader-key'.")
#+end_src

****** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

#+begin_src emacs-lisp
(general-create-definer define-leader-key!
  :prefix void-leader-key
  :non-normal-prefix void-leader-alt-key
  :keymaps 'override
  :states '(normal motion insert emacs))
#+end_src

****** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (let ((shared-args '(:keymaps 'override :states '(normal motion insert emacs))))
    `(progn (general-def
              ,@args
              ,@shared-args
              :prefix void-localleader-key
              :non-normal-prefix void-localleader-alt-key)
            (general-def
              ,@args
              ,@shared-args
              :prefix void-localleader-short-key
              :non-normal-prefix void-localleader-short-alt-key))))
#+end_src

**** s
:PROPERTIES:
:ID: 4b82deb0-bbe1-452c-8b60-ef734efb86d8
:END:

#+begin_src emacs-lisp
(use-package! s
  :demand t)
#+end_src

**** gc
:PROPERTIES:
:ID: 4f1477b7-7b28-4a20-9a31-cc34a10f5878
:END:

Wait until idle time to garbage collect while staving off garbage collector
while the user is working.

#+begin_src emacs-lisp
(use-package! gcmh
  :hook emacs-startup
  :setq
  (gcmh-idle-delay . 10)
  (gcmh-verbose . void-debug-p)
  (gcmh-high-cons-threshold . (* 16 1024 1024)))
#+end_src

**** shut-up
:PROPERTIES:
:ID:       65590d3e-ef24-4214-a602-2f4728b2f8c1
:END:

#+begin_src emacs-lisp
(use-package! shut-up
  :commands shut-up
  :init
  (defalias 'shut-up! 'shut-up)
  (defalias 'quiet! 'shut-up))
#+end_src

**** keyfreq
:PROPERTIES:
:ID:       626b35f7-eef1-4a75-b2dc-8600c1ac47b7
:END:

#+begin_src emacs-lisp
(use-package! keyfreq
  :hook emacs-startup)
#+end_src

** Initialize
:PROPERTIES:
:ID:       6e1d0ef3-5a9b-4db4-b8f7-110e96f2d23e
:END:

*** defined in c source code
:PROPERTIES:
:ID:       873e6820-52f0-4b70-9992-ccb1610eb266
:END:

**** default settings
:PROPERTIES:
:ID: 8d578668-9b0b-4117-bf93-f556e970527b
:END:

#+begin_src emacs-lisp
(setq-default fringe-indicator-alist
              (delq (assq 'continuation fringe-indicator-alist)
                    fringe-indicator-alist))
(setq-default highlight-nonselected-windows nil)
(setq-default indicate-buffer-boundaries nil)
(setq-default inhibit-compacting-font-caches t)
(setq-default max-mini-window-height 0.3)
(setq-default mode-line-default-help-echo nil)
(setq-default mouse-yank-at-point t)
(setq-default resize-mini-windows 'grow-only)
(setq-default show-help-function nil)
(setq-default use-dialog-box nil)
(setq-default visible-cursor t)
(setq-default x-stretch-cursor nil)
(setq-default ring-bell-function #'ignore)
(setq-default visible-bell nil)
(setq-default window-resize-pixelwise t)
(setq-default frame-resize-pixelwise t)
#+end_src

**** compilation
:PROPERTIES:
:ID: 65c83b28-9bee-48fe-856a-f9c38f28c817
:END:

#+begin_src emacs-lisp
;; Non-nil means load prefers the newest version of a file.
(setq-default load-prefer-newer t)
#+end_src

**** all
:PROPERTIES:
:ID:       276d0193-5a46-4034-b145-f235178678d6
:END:

#+begin_src emacs-lisp
;; File name in which to write a list of all auto save file names.
(setq auto-save-list-file-name (concat VOID-DATA-DIR "autosave"))
;; Directory of score files for games which come with GNU Emacs.
(setq shared-game-score-directory (concat VOID-DATA-DIR "shared-game-score/"))

(setq-default cursor-in-non-selected-windows nil)

(setq highlight-nonselected-windows nil)

;; When non-nil, accelerate scrolling operations.
(setq fast-but-imprecise-scrolling t)

(setq-default frame-inhibit-implied-resize t)

;; Non-nil means use lockfiles to avoid editing collisions.
(setq-default create-lockfiles nil)
;; Non-nil says by default do auto-saving of every file-visiting buffer.
(setq-default history-length 500)
;; Specifies whether to use the system's trash can.
(setq-default delete-by-moving-to-trash t)

;; Disabling bidirectional text provides a small performance boost. Bidirectional
;; text is useful for languages that read right to left.
(setq-default bidi-display-reordering 'left-to-right)
(setq-default bidi-paragraph-direction 'left-to-right)

;; Non-nil means echo keystrokes after this many seconds. A value of zero means
;; don't echo at all.
(setq-default echo-keystrokes 0)

;; Template for displaying mode line for current buffer.
(setq-default mode-line-format nil)

(setq-default locale-coding-system VOID-DEFAULT-CODING-SYSTEM)
(setq-default buffer-file-coding-system VOID-DEFAULT-CODING-SYSTEM)
#+end_src

**** scrolling
:PROPERTIES:
:ID: 21e56e37-5ff8-40d8-9f27-c3a3ab37dfb8
:END:

#+begin_src emacs-lisp
(setq-default hscroll-margin 2)
(setq-default hscroll-step 1)
(setq-default scroll-conservatively 1001)
(setq-default scroll-margin 0)
(setq-default scroll-preserve-screen-position t)
#+end_src

***** spacing
:PROPERTIES:
:ID: 8b3f38f9-b789-43e3-b2c5-5152a67d2803
:END:

#+begin_src emacs-lisp
(setq-default fill-column 80)
(setq-default sentence-end-double-space nil)
(setq-default tab-width 4)
#+end_src

***** line wrapping
:PROPERTIES:
:ID: e1564e28-d2ab-4649-b18b-24c27b897256
:END:

#+begin_src emacs-lisp
(setq-default word-wrap t)
(setq-default indicate-empty-lines nil)
(setq-default indent-tabs-mode nil)
(setq-default truncate-lines t)
(setq-default truncate-partial-width-windows 50)
#+end_src

***** other
:PROPERTIES:
:ID: cd0aa7ad-97bc-48ec-9a09-8af56cbf6157
:END:

#+begin_src emacs-lisp
;; Non-nil means reorder bidirectional text for display in the visual order.
;; Disabling this gives Emacs a tiny performance boost.
(setq-default bidi-display-reordering nil)
(setq-default cursor-in-non-selected-windows nil)
(setq-default display-line-numbers-width 3)
(setq-default enable-recursive-minibuffers t)
(setq-default frame-inhibit-implied-resize t)
#+end_src

**** printing
:PROPERTIES:
:ID: 2dfce297-0f01-4576-ae5d-bb5856591ecb
:END:

When eval and replacing expressions, I want the printed result to express all
newlines in strings as =\n= as opposed to an actual newline. In fact, in general I
want any character to be expressed in =backslash + number or character= form. It
makes the strings more readable and easier to deal with.

Furthermore, I'd like printed lisp expressions to express quoted forms the way I
write them, with a ='= as opposed to the literal =(quote ...)=.

There comes a point when output is too long, or too nested to be usable. It's ok
to abbreviate it at this point.

#+begin_src emacs-lisp
(setq-default print-escape-newlines t)
(setq-default print-escape-multibyte t)
(setq-default print-escape-control-characters t)
(setq-default print-escape-nonascii t)
(setq-default print-length nil)
(setq-default print-level nil)
(setq-default print-quoted t)
(setq-default print-escape-newlines t)
#+end_src

*** OS
:PROPERTIES:
:ID: e3d140d2-77c3-46bd-b94d-ab7196190a67
:END:

**** =abbreviated-home-dir=
:PROPERTIES:
:ID: 345958e8-fb62-4b27-b30e-c4e8b69804cd
:END:

Emacs on windows often confuses =HOME= (=C:\Users\<NAME>=) and =APPDATA=, causing
[[hvar:abbreviate-home-dir][abbreviate-home-dir]] to produce incorrect paths.

#+begin_src emacs-lisp
(with-os! windows
  (setq abbreviated-home-dir "\\`'"))
#+end_src

**** font caches
:PROPERTIES:
:ID: 339f6b4b-424c-4057-b7ea-d44c69b0f9fb
:END:

Font compacting can be terribly expensive, especially for rendering icon
fonts on Windows. Whether it has a noteable affect on Linux and Mac hasn't
been determined.

#+begin_src emacs-lisp
(with-os! windows
  (setq inhibit-compacting-font-caches t))
#+end_src

**** windows performance
:PROPERTIES:
:ID: eda95bfe-8033-42f0-9038-11da6f9bd8fb
:END:

Reduce the workload when doing file IO.

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil))
#+end_src

**** unnecessary command line options
:PROPERTIES:
:ID: 0bfbc8e5-88f3-4e19-a9d5-bc610ce09bb2
:END:

Some command line options aren't necessary.

#+begin_src emacs-lisp
(with-os! (not linux)
  (setq command-line-x-option-alist nil))

(with-os! (not mac)
  (setq command-line-ns-option-alist nil))
#+end_src

**** windows
:PROPERTIES:
:ID: 8bd7f515-0e56-4195-a04a-5003625b2dae
:END:

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil)
  (when (display-graphic-p)
    (setenv "GIT_ASKPASS" "git-gui--askpass")))
#+end_src

**** mac                                                              :disabled:
:PROPERTIES:
:ID: e502d7e6-8b19-4300-a4fd-9a797df98402
:END:

***** defaults                                                        :disabled:
:PROPERTIES:
:ID: 8e4e5a73-5616-4aca-b939-5bad62e6c657
:END:

#+begin_src emacs-lisp
(with-os! mac
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier  'alt)
  ;; sane trackpad/mouse scroll settings
  (setq mac-redisplay-dont-reset-vscroll t)
  (setq mac-mouse-wheel-smooth-scroll nil)
  ;;  one line at a time
  (setq mouse-wheel-scroll-amount '(5 ((shift) . 2)))
  ;; don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
  (setq ns-use-native-fullscreen nil)
  ;; Don't open files from the workspace in a new frame
  (setq ns-pop-up-frames nil))
#+end_src

***** exec path from shell                                            :disabled:
:PROPERTIES:
:ID: 0cc48982-6a3e-40ee-9e95-3e21dae157b5
:END:


A known problem with GUI Emacs on MacOS (or daemons started via
launchctl or brew services): it runs in an isolated
environment, so envvars will be wrong. That includes the path
Emacs picks up. [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] fixes this.

#+begin_src emacs-lisp
(use-package! exec-path-from-shell
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :demand t
  :setq
  (exec-path-from-shell-check-startup-files . nil)
  (exec-path-from-shell-arguments . (delete "-i" exec-path-from-shell-arguments))
  (exec-path-from-shell-debug . void-debug-p)
  :init
  (nconc! exec-path-from-shell-variables
    '("LC_CTYPE" "LC_ALL" "LANG"))
  (exec-path-from-shell-initialize))
#+end_src

***** ns-auto-titlebar
:PROPERTIES:
:ID: 751ae26b-d0ae-4af1-80a5-c2b0ae360367
:END:

[[https://github.com/purcell/ns-auto-titlebar][ns-auto-titlebar]] syncs ns frame parameters with theme and fixes mismatching text
color in the frame title.

#+begin_src emacs-lisp
(use-package! ns-auto-titlebar
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :demand t)
#+end_src

***** osx-clipboard
:PROPERTIES:
:ID: 6eb19c02-ce40-4aec-9124-a58a4389855f
:END:

#+begin_src emacs-lisp
(use-package! osx-clipboard
  :os mac
  :when (or (daemonp) (not (display-graphic-p)))
  :hook emacs-startup)
#+end_src

**** linux
:PROPERTIES:
:ID: 122381a6-784b-4f56-a97e-8c1a2d18dcc0
:END:

#+begin_src emacs-lisp
(with-os! linux
  (setq x-underline-at-descent-line t)
  (setq x-gtk-use-system-tooltips nil))
#+end_src

*** void specific funtions
:PROPERTIES:
:ID: 1b49e07a-466f-41da-8b31-18c28421cf62
:END:

**** windows
:PROPERTIES:
:ID: 039a9070-2ba3-4e01-abd4-7bdb49cc5a3d
:END:

***** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun void/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

***** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun void/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

**** all
:PROPERTIES:
:ID: e97267e8-fca8-4bf2-9899-7ec694e8a767
:END:

***** quit emacs without hook
:PROPERTIES:
:ID: b82f721c-39f5-4d41-bb0f-d4c391238eb4
:END:

Sometimes something goes wrong with [[helpvar:kill-emacs-hook][kill-emacs-hook]] and because of that I can't
close emacs. For that reason, I have this function.

#+begin_src emacs-lisp
(defun void/kill-emacs-no-hook ()
  "Kill emacs, ignoring `kill-emacs-hook'."
  (interactive)
  (when (yes-or-no-p "Quit without `kill-emacs-hook'?")
    (let (kill-emacs-hook) (kill-emacs))))
#+end_src

***** quit emacs brutally
:PROPERTIES:
:ID: 8753217c-4722-4183-bbb3-049707a37e54
:END:

I've never had to use this. But better be safe than sorry.

#+begin_src emacs-lisp
(defun void/kill-emacs-brutally ()
  "Tell an external process to kill emacs."
  (interactive)
  (when (yes-or-no-p "Do you want to BRUTALLY kill emacs?")
    (call-process "kill" nil nil nil "-9" (number-to-string (emacs-pid)))))
#+end_src

***** new emacs instance
:PROPERTIES:
:ID: eaf80ec3-2bd4-4f05-8a9c-fa525894a6fe
:END:

#+begin_src emacs-lisp
(defun void/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

***** kill all process of program
:PROPERTIES:
:ID: 913952e2-3727-4b38-aefc-4618c2771730
:END:

#+begin_src emacs-lisp
(defun void/kill-emacs-processes ()
  (interactive)
  (let ((count 1) (process "emacs"))
    (kill-process process)
    (while (ignore-errors (kill-process process))
      (setq process (format "emacs<%d>" count))
      (cl-incf count))
    (message "killed %d processes" count)))
#+end_src

***** qutebrowser
:PROPERTIES:
:ID: 77bace13-5af8-4974-981a-e07bf271182f
:END:

#+begin_src emacs-lisp
(defun void/open-qutebrowser ()
  "Open qutebrowser."
  (interactive)
  (start-process "qutebrowser" nil "qutebrowser"))
#+end_src

**** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun void/switch-to-messages ()
  (interactive)
  (select-window (display-buffer (get-buffer "*Messages*"))))
#+end_src

**** main org file
:PROPERTIES:
:ID: fb605553-f234-410a-b27e-697dc667831b
:END:

#+begin_src emacs-lisp
(defun void/switch-to-main-org-file ()
  (interactive)
  (find-file (concat VOID-EMACS-DIR "README.org")))
#+end_src

**** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun void/switch-to-capture-file ()
  (interactive)
  (switch-to-buffer (find-file VOID-CAPTURE-FILE)))
#+end_src

**** turn on debug-mode
:PROPERTIES:
:ID: c1ac481a-6ebd-49ce-a930-3b0593283aee
:END:

#+begin_src emacs-lisp
(defun void/enable-debug-mode ()
  (interactive)
  (setq void-debug-p t))
#+end_src

**** switch to init file
:PROPERTIES:
:ID: 50c5e173-d737-4264-bac5-f13190d468dc
:END:

#+begin_src emacs-lisp
(defun void/switch-to-init-org-file ()
  "Switch to Void's init.el file."
  (interactive)
  (switch-to-buffer VOID-INIT-FILE))
#+end_src

**** quit emacs no prompt
:PROPERTIES:
:ID: d530718a-2b42-4e9b-8d7d-7813e0ae6381
:END:

#+begin_src emacs-lisp
(defun void/quit-emacs-no-prompt ()
  "Quit emacs without prompting."
  (interactive)
  (let (confirm-kill-emacs)
    (kill-emacs)))
#+end_src

*** post init
:PROPERTIES:
:ID: 0f1da89a-2278-4493-ba62-e2a334204be6
:END:

**** idle require
:PROPERTIES:
:ID:       c550f82a-9608-47e6-972b-eca460015e3c
:END:

This package.

#+begin_src emacs-lisp
(use-package! idle-require
  :demand t
  :hook emacs-startup
  :setq
  (idle-require-idle-delay . 7)
  (idle-require-load-break . 2))
#+end_src

**** =tty=
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

When running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (void-add-advice #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

**** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `VOID-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold VOID-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `void-gc-cons-threshold' after delay."
  (run-with-idle-timer 3 nil (lambda () (setq gc-cons-threshold VOID-GC-CONS-THRESHOLD))))
#+end_src

**** tangling
:PROPERTIES:
:ID: 3288c787-4b5c-4f0c-9d18-6f18afaf2b99
:END:

***** tangle hook
:PROPERTIES:
:ID: 549999d7-901b-4ab4-bdbe-81514b756ced
:END:

Void tangles itself just before quitting if [[helpfn:void-needs-tangling-p][void-needs-tangling-p]] returns true.
I tangle before quitting so I don't have to do it before startup. It's
preferable for quitting emacs to be slightly slower than for emacs startup to
be.

#+begin_src emacs-lisp
(defhook! tangle-on-quit-maybe (kill-emacs-hook :append t)
  "Tangle if `void-needs-tangling-p' returns t."
  (when (void-needs-tangling-p)
    (void/tangle-org-file)))
#+end_src

***** tangle asynchronously upon saving
:PROPERTIES:
:ID: 00298d4e-6b18-4203-874f-f5a877a5cabf
:END:

This is another attempt to keep my =main.el= file in sync as much as possible with
[[helpvar:VOID-README-FILE][void-main-org-file]]. ~void-tangle-on-save-h~ is called whenever a buffer is being
saved to a file. The reason why I use ~cl-letf~ to temporarily override [[helpfn:load][load]] is
because ~VOID-INIT-FILE~ already contains all the code I need so I don't want it
to waste time loading ~void-main-elisp-file~.

#+begin_src emacs-lisp
(defhook! tangle-maybe (after-save-hook)
  "Tangle `VOID-README-FILE' asynchronously when it is saved."
  (when (and (require 'async nil t)
             (string= (file-truename VOID-README-FILE)
                      (or (buffer-file-name (current-buffer)) ""))
             (void-needs-tangling-p))
    (async-start
     (lambda ()
       (let ((old-fn (symbol-function 'load))
             (user-init-file (concat user-emacs-directory "init.el")))
         (require 'cl)
         (cl-letf (((symbol-function 'load)
                    (lambda (file &rest args)
                      (when (string= user-init-file file)
                        (apply old-fn file args)))))
           (load user-init-file))))
     (lambda (_)
       (void-log
        (concat (if (void-needs-tangling-p) "✕ failed" "✓ succeeded")
                " tangling `VOID-README-FILE'."))))))
#+end_src

** UI
:PROPERTIES:
:ID: c21a5946-38b1-40dd-b6c3-da41fb5c4a5c
:END:

*** maybe get rid of UI elements
:PROPERTIES:
:ID: 3f466dd8-13f1-4160-a2a5-da1acd4f3d3e
:END:

Emacs 27 and above allows the user to customize the UI in =early-init.el=. For
easy backwards usage previous version of emacs (25 and 26) I include.

#+begin_src emacs-lisp
(when (version< emacs-version "27")
  (ignore-errors
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (menu-bar-mode -1)))
#+end_src

*** fullscreen
:PROPERTIES:
:ID: f0aad350-7da3-4350-8041-45bc5372ef7e
:END:

By default start emacs as fullscreen.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

*** hooks
:PROPERTIES:
:ID: ede94ae4-1c73-4435-81ba-e28070225b99
:END:

*** font
:PROPERTIES:
:ID: 893a1c9b-985b-4da8-9d9b-73028be5a2db
:END:

**** determine which font to use
:PROPERTIES:
:ID: 86cc1277-91ef-4a47-800b-8ec58cd8c6c6
:END:

I want Void to be flexible when choosing a font. I create a list of my preferred
fonts in =void-backup-fonts=. They are in order of most preferred to least
preferred. To compute the value of =void-font=, Void checks each of these fonts
in turn for the first available font. If none is availabe it just uses the
system font.

This process is time consuming (at least relative to the total emacs startup
time). But it benefits from byte-compilation.

#+begin_src emacs-lisp
(defvar void-backup-fonts
  '("Inconsolata-18" "Fira Code-18" "DejaVu Sans Mono-18"))

(defvar void-font "Courier 10 Pitch-18"
  "Default font for Void Emacs.
The font for Void is the first font in `void-backup-fonts' that's found in the
computer. If no font in `void-backup-fonts' is found then it uses the default
system font.")
#+end_src

**** specify =void-font= as default
:PROPERTIES:
:ID: 911e25ba-0893-487f-9f6b-8a574faf6f7d
:END:

The =default-frame-alist= is an alist of the default values for creating a
frame. So here I'm making the default font for all Emacs frames =void-font=.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist (cons 'font void-font))
#+end_src

**** catch undefined fonts
:PROPERTIES:
:ID: e7c8fa94-5efa-462e-9302-57a6935a1c89
:END:

#+begin_src emacs-lisp
(defadvice! set-font (:around frame-notice-user-settings)
  "Try `void-font' followed each of `void-backup-fonts' until success.
If none of the fonts work, just use the default system font."
  (condition-case nil
      (progn (apply <orig-fn> <args>)
             (void-log "Font is: %s" (face-attribute 'default :font)))
    (error
     (if void-backup-fonts
         (progn
           ;; (push (cons err nil) void-init-errors)
           (void-log "Setting %s failed. Trying %s..." void-font (car void-backup-fonts))
           (setq void-font (pop void-backup-fonts))
           (add-to-list 'default-frame-alist (cons 'font void-font))
           ;; I want to call the function with advice in it.
           (apply <orig-fn> <args>))
       (setq void-font (face-attribute 'default :font))
       (void-log "None of the backup-fonts worked, defaulting to: %s"
                 void-font)
       (add-to-list 'default-frame-alist (cons 'font void-font))
       (apply <orig-fn> <args>)))))
#+end_src

**** size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun void/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

*** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

**** theme to load
:PROPERTIES:
:ID: cd085611-9e56-4df4-97dd-f087899562c0
:END:

#+begin_src emacs-lisp
(defvar void-theme 'one-light
  "The theme to load on startup.
The value of this variable is updated to the current theme whenever `load-theme'
is called.")

(setq custom-safe-themes t)
#+end_src

**** initialize at startup
:PROPERTIES:
:ID: 06b1f381-9066-4062-88d5-f376ad5d6df0
:END:

#+begin_src emacs-lisp
(defhook! set-theme (window-setup-hook)
  "Set the theme and load the font, in that order."
  (when (and void-theme (not (memq void-theme custom-enabled-themes)))
    (condition-case nil
        (load-theme void-theme t)
      (error (void-log "Could not load %s" void-theme)))))
#+end_src

**** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar void-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `void-load-theme-hook' to run after `load-theme' is called."
  (setq void-theme <theme>)
  (run-hooks 'void-after-load-theme-hook))
#+end_src

**** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! disable-old-themes (:around load-theme)
  "Disable old themes before loading new ones."
  (mapc #'disable-theme custom-enabled-themes)
  (apply <orig-fn> <args>))
#+end_src

* Window Management
:PROPERTIES:
:ID: 29dbf899-17cd-4b00-aacb-090ccd20e133
:END:

Window management is one of the most important things to get right if you're
going to be efficient in emacs (that is unless you're using primarily frames
instead of windows).

** ace-window
:PROPERTIES:
:ID: b7cb25b4-ede8-4350-846c-d5c243a4a937
:END:

[[https://github.com/abo-abo/ace-window][ace-window]] uses avy to navigate windows in cases when there are many. There is
an alternative package for this, [[https://github.com/dimitri/switch-window][switch-window]]. The advantage of =switch-window=
is that the characters used for switching to a window are *really* easy to see,
but you can't see the buffer contents. That's a no-go for me I need to see them.

#+begin_src emacs-lisp
(use-package! ace-window
  :commands ace-window ace-swap-window
  :bind ([remap other-window] . ace-window)
  :setq
  (aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-background . t))
#+end_src

** eyebrowse
:PROPERTIES:
:ID: 4ad6f8e6-0465-4d84-aa71-8848e69ccc5c
:END:

[[https://github.com/wasamasa/eyebrowse][eyebrowse]] is for managing workspaces. A workspace in Emacs a specific window
setup. It's for when you are doing some task let's say researching some
eyebrowse code and then you want to take a break and do something else but you
don't want to close all the nice windows you have up (and have to set them up
again later). You can create a new workspace with [[helpfn:eyebrowse-create-window-config][eyebrowse-create-window-config]]
and switch to it with [[helpfn:eyebrowse-next-window-config][eyebrowse-next-window-config]]. You can always go back to
your previous workspace now with [[helpfn:eyebrowse-prev-window-config][eyebrowse-prev-window-config]] or
[[helpfn:eyebrowse-switch-to-window-config][eyebrowse-switch-to-window-config]].

#+begin_src emacs-lisp
(use-package! eyebrowse
  :commands eyebrowse-create-window-config
  :setq (eyebrowse-wrap-around . t))
#+end_src

** window divider
:PROPERTIES:
:ID: 0bcebb71-f730-427f-9919-1538bd63456c
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

*** window dividers
:PROPERTIES:
:ID: 849718ae-9d4a-43ab-b113-584aefa87c5b
:END:

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

#+begin_src emacs-lisp
(use-feature! frame
  :hook (window-setup . window-divider-mode)
  :custom
  (window-divider-default-places  t)
  (window-divider-default-bottom-width 10)
  (window-divider-default-right-width  10)
  :config
  (set-face-foreground 'window-divider "black")
  (blink-cursor-mode -1))
#+end_src

*** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (void-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

**** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame:adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

**** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

**** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

** transpose-frame
:PROPERTIES:
:ID: 5487535d-2534-4857-b1e0-c63b40917710
:END:

https://www.emacswiki.org/emacs/TransposeFrame

#+begin_src emacs-lisp
(use-package! transpose-frame
  :commands
  transpose-frame
  flip-frame
  flop-frame
  rotate-frame
  rotate-frame-clockwise)
#+end_src

** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.
There are benefits and drawbacks to making emacs your window manager. One
benefit is that you get a super consistent window management experience. If you
use a typical window manager, you have to.

*** download webpage as pdf
:PROPERTIES:
:ID:       bd7165df-9dae-4954-b153-96335678e296
:END:

Storing the links is better, but not good enough. Webpages die. They can be
taken off by a third-party or removed by the owner themselves. Even if they
aren't though, they can be modified so that what you originally found isn't
there anymore. As a solution for this I came upon [[https://wkhtmltopdf.org/][wkhtmltopdf]], a command that
downloads a given webpage as pdf. A consequence of doing this is that you will
have access to all the webpages you used for research offline.

#+begin_src emacs-lisp
(defun void-save-webpage (url webpage-title)
  "Save the webpage at URL to `void-screenshot-dir'."
  (let* ((program "wkhtmltopdf")
         (name (format "%s - %s" program (ts-format)))
         (webpage-title (s-replace "/" "~" webpage-title))
         (pdf-path (format "%s%s.pdf" VOID-SCREENSHOT-DIR webpage-title))
         (fn `(lambda (&rest _)
                (if (file-exists-p ,pdf-path)
                    (message "Webpage saved succesfully.")
                  (warn "Failed to save webpage %s to %s." ,url ,pdf-path)))))
    (message "%s <-- %s" (f-abbrev pdf-path) url)
    (async-start-process name "firejail" fn program url pdf-path)))
#+end_src

*** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun exwm::title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

*** org capture from an exwm buffer
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[][]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

**** replacement for fake id
:PROPERTIES:
:ID:       4f0436c4-bc37-49b0-a8a3-894e212d4d13
:END:

#+begin_src emacs-lisp
(defun exwm-input::fake-key-to-id (event id)
  "Fake a key event equivalent to Emacs event EVENT and send it
 to program with x window ID."
  (let* ((keysym (xcb:keysyms:event->keysym exwm--connection event))
         keycode)
    (when (= 0 (car keysym))
      (user-error "[EXWM] Invalid key: %s" (single-key-description event)))
    (setq keycode (xcb:keysyms:keysym->keycode exwm--connection
					                           (car keysym)))
    (when (/= 0 keycode)
      (dolist (class '(xcb:KeyPress xcb:KeyRelease))
        (xcb:+request exwm--connection
	        (make-instance
	         'xcb:SendEvent
	         :propagate 0 :destination id
	         :event-mask xcb:EventMask:NoEvent
	         :event
	         (xcb:marshal
	          (make-instance
	           class
	           :detail keycode :time xcb:Time:CurrentTime
	           :root exwm--root :event id :child 0 :root-x 0 :root-y 0
	           :event-x 0 :event-y 0 :state (cdr keysym) :same-screen 0)
	          exwm--connection)))))
    (xcb:flush exwm--connection)))
#+end_src

**** url from firefox
:PROPERTIES:
:ID:       f407cc8c-0bb9-47fe-adeb-4e9d27b5c5b7
:END:

Emacs simulates a keypress to firefox--specifically the keypresses to select the
current url and to add it to the kill ring.

#+begin_src emacs-lisp
(defun exwm::firefox-url ()
  "Save the current firefox url to kill ring."
  ;; We get the xwindow id of the buffer named Firefox
  (let ((fid (exwm--buffer->id (current-buffer))))
    ;; Send c-l to select url
    (exwm-input::fake-key-to-id 'C-l fid)
    ;; We sleep to avoid race conditions.
    (sleep-for 0 300)
    ;; Copy url to kill ring (note: this is not affected by simulation keys)
    (exwm-input::fake-key-to-id 'C-c fid)
    (sleep-for 0 300)
    ;; try to set the state back
    (exwm-input::fake-key-to-id 'escape fid)
    (current-kill 0)))
#+end_src

**** url from qutebrowser
:PROPERTIES:
:ID:       822cbb61-60b4-445e-9756-4bf797500375
:END:

#+begin_src emacs-lisp
(defun exwm::qutebrowser-url ()
  (interactive)
  (let ((fid (exwm--buffer->id (current-buffer))))
    (sleep-for 0 300)
    ;; if in insert state exit it.
    (exwm-input::fake-key-to-id 'escape fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (aprog1 (current-kill 0)
      (void-log "Copied %S to the kill ring." it))))
#+end_src

**** webpage regexp
:PROPERTIES:
:ID:       b2841e60-9580-4b3e-a7ee-287527e137a7
:END:

#+begin_src emacs-lisp
(defvar exwm::website-regexp nil
  "Regexp used to.")
#+end_src

**** exwm webpage name
:PROPERTIES:
:ID:       1dd32c50-48cb-48a7-b401-613beae5e079
:END:

#+begin_src emacs-lisp
(defun exwm::webpage-name ()
  "Return the name of the webpage."
  (->> (s-match (rx (group (1+ anything)) " - " (1+ anything)) exwm-title)
       (nth 1)))
#+end_src

*** exwm
:PROPERTIES:
:ID: 18ee4dd8-445b-4101-adfb-ba8e18a71bb4
:END:

In fact, EXWM does not need to be loaded on startup. It is only needed when you
actually want to open another application such as a separate Emacs instance or
the web browser. This is great because EXWM actually does consume significant
startup time. Instead of loading =EXWM= immediately, I add advises to the
functions which open external linux applications.

#+begin_src emacs-lisp
(use-package! exwm
  :hook (exwm-mode . hide-mode-line-mode)
  :before-call (void/open-qutebrowser counsel-linux-app void/open-emacs-instance)
  :setq (exwm-replace . nil)
  :config
  (exwm-init)
  ;; Enable the clipboard.
  (require 'exwm-systemtray)
  (exwm-systemtray-enable))

(defhook! setup-hide-mode-line (exwm-mode-hook)
  (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

**** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

**** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . void/open-qutebrowser)
             (,(kbd "s-e") . void/open-emacs-instance))))

(general-def
  "s-R" #'exwm-reset
  "s-x" #'exwm-input-toggle-keyboard
  "s-h" #'windmove-left
  "s-j" #'windmove-down
  "s-k" #'windmove-up
  "s-l" #'windmove-right
  "s-t" #'transpose-frame
  "s-D" #'kill-this-buffer
  "s-b" #'switch-to-buffer
  "s-f" #'find-file
  "s-O" #'exwm-layout-toggle-fullscreen
  "s-p" #'previous-buffer
  "s-n" #'next-buffer
  "s-q" #'void/open-qutebrowser
  "s-e" #'void/open-emacs-instance)
#+end_src

*** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

#+begin_src emacs-lisp
(use-package! exwm-edit :after exwm)
#+end_src

*** exwm firefox
:PROPERTIES:
:ID:       a78eec54-687f-4a40-8c68-db096112ef52
:END:

#+begin_src emacs-lisp
(use-package! exwm-firefox-evil
  :disabled t
  :after exwm
  :hook (exwm-manage-finish . exwm-firefox-evil-activate-if-firefox)
  :config
  (dolist (k `(escape))
    (cl-pushnew k exwm-input-prefix-keys)))
#+end_src

** buffer expose
:PROPERTIES:
:ID: df46e75c-0613-41e4-a4e4-a477f112adcb
:END:

#+begin_src emacs-lisp
(use-package! buffer-expose
  :commands
  buffer-expose
  buffer-expose-no-stars
  buffer-expose-major-mode
  buffer-expose-dired-buffers
  buffer-expose-stars
  buffer-expose-current-mode
  :setq
  (buffer-expose-show-current-buffer . t)
  (buffer-expose-rescale-factor      . 0.5)
  (buffer-expose-highlight-selected  . nil)
  (buffer-expose-max-num-windows     . 8)
  (buffer-expose-auto-init-aw        . t)
  (buffer-expose-hide-modelines      . nil)
  (buffer-expose-key-hint            . "")
  :bind
  (:map buffer-expose-grid-map
   ("l" . buffer-expose-next-window)
   ("h" . buffer-expose-prev-window)
   ("L" . buffer-expose-next-page)
   ("H" . buffer-expose-prev-page)
   ("j" . buffer-expose-down-window)
   ("k" . buffer-expose-up-window)))
#+end_src

* Completion
:PROPERTIES:
:ID: 056384d1-a95a-4dcb-bc9d-ffe95bbb52a8
:END:

Completion has certainly become an integral part of any efficient workflow. One
commonality among things like searching emails, code-completing a word, surfing
the web is that in one way or another all of these things involve the suggestion
of likely candidates from a population that is too time consuming to look
through on our own. It's not much different in Emacs. We're constantly sifting
though files, buffers, commands, words--all to try to get through to the subset
of things that we actually want at this moment.

** snippets
:PROPERTIES:
:ID:       02dd54d0-f545-447e-89cf-c0cfcd941c76
:END:

*** defsnippet
:PROPERTIES:
:ID:       bfaa2631-a300-4f38-b31d-ec7457b18491
:END:

I find it painful to write and edit long one-liner snippets with lots of inner
elisp code. Additionally, I dislike having many different files for snippets. To
me it's a potential source of errors and it makes it so I have to go looking for
a snippet whenever I want to edit it.

These grievances have inspired me to write an API for writing snippet templates
in a declarative syntax as opposed to via a snippet file.

**** defsnippet

This is the user-facing function to define yasnippets.

#+begin_src emacs-lisp
(defun defsnippet:new-snippet (&rest plist)
  "Define a snippet."
  (-let (((&plist :name :mode :body :placeholders) plist)
         (keys '(:key :name :contributor :group :expand-env :binding :type :uuid)))
    (cl-assert (-none-p #'null (list name mode body)))

    (alet (append
           (list "# -*- mode: snippet -*-\n")
           (->> keys
                (--filter (plist-get plist it))
                (--map (format "# %s: %s\n" (void-keyword-name it) (plist-get plist it))))
           (list "# --\n")
           (list (defsnippet:compute-body body placeholders)))
      (with-temp-buffer
        (insert (string-join it "\n"))
        (yas-load-snippet-buffer mode)))))
#+end_src

**** compute body
:PROPERTIES:
:ID:       e6bbca2d-ee83-4cab-b115-9098bb0962c6
:END:

#+begin_src emacs-lisp
(defun defsnippet:compute-body (body placeholders)
  "Return the result of PLACEHOLDERS applied to BODY."
  (alet (-map (-lambda ((number name form))
                (if (eq '_  name)
                    (format "${%d:$$%S}" number form)
                  (format "${%d:%s$%S}" number name form)))
              placeholders)
    (apply #'format body it)))
#+end_src

**** list symbols
:PROPERTIES:
:ID:       56de420c-0cb7-47fb-ad34-c562047cd4fd
:END:

#+begin_src emacs-lisp
(defun defsnippet:list-symbols (&optional pred)
  "List interned symbols."
  (setq pred (or pred #'identity))
  (let (acc)
    (mapatoms (lambda (it)
                (when (and (symbolp it)
                           (not (eq 'nil it))
                           (funcall pred it))
                  (push it acc))))
    (nreverse acc)))
#+end_src

**** defsnippet!
:PROPERTIES:
:ID:       36e73e8a-86bb-4ab0-adc6-e6ff3e263237
:END:

This macro helps me define snippets declaratively without worrying about whether
yasnippet is loaded or not.

#+begin_src emacs-lisp
(defmacro defsnippet! (snippet &rest properties)
  "Syntactic sugar for defining a snippet on time."
  (declare (indent defun))
  `(after! yasnippet
     (defsnippet:new-snippet
       :name ,(void-to-string snippet)
       ,@properties)))
#+end_src

**** snippets
:PROPERTIES:
:ID:       a2fd6032-4c48-43c6-9afa-350dc74f47ac
:END:

It's really nice being able to re-evaluate a snippet with an elisp form as
opposed to going to the snippet buffer, editing it and reloading it.

***** org links
:PROPERTIES:
:ID:       df615fc9-cfac-4bed-b8ef-c5fcf57dffca
:END:

****** helpfn
:PROPERTIES:
:ID:       ca5d380a-05a9-4d74-8440-8e972d86661c
:END:

For extremely good documentation.

#+begin_src emacs-lisp
(defsnippet! help-function
  :key "hfn"
  :mode 'org-mode
  :body "[[helpfn:%s][$1]%s"
  :placeholders '((1 function (yas-auto-next (yas-choose-value (defsnippet:list-symbols))))
                  (0 _ (insert "]"))))
#+end_src

****** helpvar
:PROPERTIES:
:ID:       c1b65fb3-1d6f-4ec4-81b2-23d92e713332
:END:

#+begin_src emacs-lisp
(defsnippet! help-variable
  :mode 'org-mode
  :key "hvar"
  :body "[[helpvar:$1][%s]%s"
  :placeholders '((1 variable (->> (defsnippet:list-symbols #'helpful--variable-p)
                               (yas-choose-value)
                               (yas-auto-next)))
                  (0 _ (insert "]"))))
#+end_src

****** id
:PROPERTIES:
:ID:       84b143bb-cd83-4dd4-b0e1-264b7e2d4aaa
:END:

#+begin_src emacs-lisp
(defsnippet! org-id
  :mode 'org-mode
  :key "oid"
  :body "[[id:%s][#%s]$0"
  :placeholders '((1 _ (->> (hash-table-keys org-id-locations)
                        (yas-choose-value)
                        (yas-auto-next)))
                  (2 _ (substring (yas-field-value 1) 0 5))
                  (0 _ (insert "]"))))
#+end_src

***** elisp
:PROPERTIES:
:ID:       996f1990-991a-4cce-bfc9-629e52286ad6
:END:

****** defun
:PROPERTIES:
:ID:       ae185254-d541-42a8-acc9-c2907236a945
:END:

#+begin_src emacs-lisp
(defsnippet! defun
  :mode 'emacs-lisp-mode
  :key "dfn"
  :body "(defun %s (%s)\n  \"%s\"\n  %s)"
  :placeholders '((1 name)
                  (2 args)
                  (3 docstring (thread-first (rx-to-string `(or ,@(s-split "\s" (yas-field-value 2) t)))
                                (replace-regexp-in-string #'upcase yas-text)
                                (ignore-errors)))
                  (4 body)))
#+end_src

*** yasnippet
:PROPERTIES:
:ID: 1f362298-2b47-4929-9484-ce7f26f80adf
:END:

[[https://github.com/joaotavora/yasnippet][yasnippet]] is a template completion package. You can define templates which can
be inserted and interactively completed.

#+begin_src emacs-lisp
(use-package! yasnippet
  :hook (prog-mode . yas-minor-mode-on)
  :setq
  (yas-snippet-dirs . (list (concat VOID-DATA-DIR "snippets/")))
  (yas-verbosity . (if void-debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :config
  (--each yas-snippet-dirs (mkdir it t))
  (delq #'yas-dropdown-prompt yas-prompt-functions)
  (after! smartparens
    ;; tell smartparens overlays not to interfere with yasnippet keybinds
    (void-add-advice #'yas-expand :before #'sp-remove-active-pair-overlay)))
#+end_src

*** snippet collection
:PROPERTIES:
:ID:       ceb066ac-2242-492d-9609-9e3b879b10b7
:END:

=yasnippet-snippets= is a collection of snippets.

#+begin_src emacs-lisp
(use-package! yasnippet-snippets
  :after yasnippet
  :init
  (awhen (-first (-partial #'s-contains-p "yasnippet-snippets") load-path)
    (push it yas-snippet-dirs)))
#+end_src

** completion framework
:PROPERTIES:
:ID: cf88854e-4f88-4f64-962d-5d0ff99cd94f
:END:

As [[id:][I've mentioned]], querying is a huge part of our workflow. In emacs, you'll
find yourself querying for the right command, or for the variable you want help
on. Traversing the jungle of candidates.

*** ivy
:PROPERTIES:
:ID:       68d2ef19-dac6-407f-9220-8da816b873e8
:END:

[[github:abo-abo/swiper][ivy]] provides a user interface for choosing from a list of options by typing a
query to narrow the list, and then selecting one of the remaining candidates.

**** bootstrap
:PROPERTIES:
:ID: 4bf12e8b-7f71-45cc-bf48-c1aec795c9fe
:END:

Here I just set up basic variables to enhance the display of ivy the way I want
it. I prefer a minibuffer that's a consistent height to avoid visual
distraction. Note that "virtual" buffers here just mean a list of files that had
been recently opened buffers (this list is managed by [[f26bedb3-a172-4543-afd0-4c47f5872d15][recentf]]).

#+begin_src emacs-lisp
(use-package! ivy
  :hook emacs-startup
  :custom
  (ivy-initial-inputs-alist . nil)
  :setq
  (ivy-mark-prefix . "> ")
  (ivy-sort-max-size . 40000)
  (ivy-height . 18)
  (ivy-wrap . nil)
  (ivy-fixed-height-minibuffer . t)
  (ivy-use-selectable-prompt . t)
  (ivy-use-virtual-buffers . t)
  (ivy-virtual-abbreviate . 'full)
  (ivy-on-delete-error-function . nil)
  (ivy-use-selectable-prompt . t)
  (ivy-count-format . "%-4d "))
#+end_src

**** ivy-avy
:PROPERTIES:
:ID:       a1224932-eb2b-4f6c-949b-de9383506ab8
:END:

[[https://github.com/abo-abo/swiper/blob/master/ivy-avy.el][ivy-avy]] is the integration of ivy with [[https://github.com/abo-abo/avy][avy]]. The idea is to have the ability
to select candidates quickly.

#+begin_src emacs-lisp
(use-package! ivy-avy
  :bind (:map ivy-minibuffer-map
         ("C-'" . ivy-avy)))
#+end_src

**** minibuffer bindings
:PROPERTIES:
:ID:       5a21af24-4383-40dc-8c53-562f2cf68961
:END:

These bindings are influenced by some of helm's minibuffer bindings (namely
=C-l= and =C-a=). They are also influenced by evil bindings, hence using =C-j=
and =C-k= instead of the emacs staple =C-p= and =C-n=.

Note that [[helpfn:ivy-immediate-done][ivy-immediate-done]] selects uses the minibuffer input as the current
candidate.

#+begin_src emacs-lisp
(general-def '(emacs insert) ivy-minibuffer-map
  "C-k"     #'ivy-previous-line
  "C-j"     #'ivy-next-line
  [backtab] #'ivy-previous-line
  "C-a"     #'ivy-dispatching-done
  "C-n"     #'ivy-toggle-marks
  "C-l"     #'ivy-next-line-and-call
  "C-o"     #'ivy-occur
  "C-'"     #'ivy-avy
  "C-d"     #'ivy-immediate-done
  "RET"     #'ivy-done)

(general-def '(emacs insert) ivy-minibuffer-map "TAB" #'ivy-next-line)
#+end_src

**** remembering used candidates
:PROPERTIES:
:ID:       203dd3f4-bec7-4e3f-b1cf-30089f2ccb32
:END:

Most of us only use a small subset of commands. Prescient is a package that
remembers the candidates you select using ivy. It saves them in
[[helpvar:prescient-save-file][prescient-save-file]]. These saved candidates are then placed at the top of the
next completion.

#+begin_src emacs-lisp
(use-package! prescient
  :pre-setq (prescient-save-file . (concat VOID-DATA-DIR "prescient-save.el"))
  :hook (ivy-mode . prescient-persist-mode))
#+end_src

**** sorting and filtering
:PROPERTIES:
:ID: ec8cd466-c6cf-4b25-9624-07e9d0e0fd0c
:END:

Candidates are sorted once before the first display, and if the user types input
they are filtered in real time. [[https://github.com/raxod502/prescient.el][ivy-prescient]] provides a sorting and
filtering algorithm that I find preferrable to ivy's defaults.

#+begin_src emacs-lisp
(use-package! ivy-prescient
  :hook ivy-mode
  :setq
  (ivy-prescient-sort-commands . '(:not swiper swiper-isearch ivy-switch-buffer))
  (ivy-prescient-retain-classic-highlighting . t))
#+end_src

**** selecting multiple candidates
:PROPERTIES:
:ID: 2414a29d-e874-4174-8f90-b9d80c001026
:END:

If you want to perform an action on multiple candidates, you mark the ones you
want to perform the action on first. Ivy comes with a function to mark and a
function to unmark but not with one that toggles marking. This function allows
you to [[file:./multimedia/gifs/ivy-marking-candidates.gif][toggle marking a candidate]]. The candidate is marked with [[helpvar:ivy-mark-prefix][ivy-mark-prefix]].

#+begin_src emacs-lisp
(defun ivy/toggle-mark ()
  "Toggle mark."
  (interactive)
  (if (ivy--marked-p) (ivy-unmark) (ivy-mark)))

(general-def '(emacs insert) ivy-minibuffer-map
  "C-SPC" #'ivy/toggle-mark)
#+end_src

*** counsel
:PROPERTIES:
:ID:       47e0919a-0852-4454-853d-7c7875760de8
:END:

Counsel is a library of convenience functions built on top of ivy.

**** don't include binding information
:PROPERTIES:
:ID:       50e3991d-8c46-4dcb-86d9-79c2bede4e50
:END:


By default [[file:./multimedia/screenshots/ivy-default-keybinding-display.png][keybinding information is displayed]]. I find that this information is
visually distracting and not particularly useful for me, so I disable it.

#+begin_src emacs-lisp
(after! counsel
  (void-add-advice #'counsel-M-x-transformer :override #'identity))
#+end_src

**** make the default action setting the font
:PROPERTIES:
:ID:       17f2d06a-835c-4bba-960b-d0f8c028a91a
:END:

[[helpfn:counsel-fonts][counsel-fonts]] does not set the font as its default action.

#+begin_src emacs-lisp
(after! ivy
  (ivy-set-actions #'counsel-fonts (list (list "o" #'void-set-font "set font")))
  (defun void-set-font (font)
    (set-face-attribute 'default nil :font font)))
#+end_src

**** counsel
:PROPERTIES:
:ID: f1f77877-1cbc-40c4-b62c-4239a0c338e6
:END:

[[https://github.com/abo-abo/swiper][counsel]] is a library that replaces a lot of stock emacs functions with a version
that using =ivy= for completion.

#+begin_src emacs-lisp
(use-package! counsel
  :hook ivy-mode
  :setq
  (counsel-find-file-ignore-regexp . "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")
  (counsel-describe-function-function . #'helpful-callable)
  (counsel-describe-variable-function . #'helpful-variable)
  (counsel-rg-base-command . "rg -zS --no-heading --line-number --color never %s .")
  (counsel-ag-base-command . "ag -zS --nocolor --nogroup %s")
  (counsel-pt-base-command . "pt -zS --nocolor --nogroup -e %s"))
#+end_src

**** remap common commands
:PROPERTIES:
:ID:       c117480c-89e6-463b-9d07-cf0155c9c617
:END:

As I mentioned, counsel is a library of convenience functions. Many of these
convenience functions are just wrappers around existing emacs functions that
provide. In this block I merely remap emacs commands to their counsel library
equivalents.

#+begin_src emacs-lisp
(general-def counsel-mode-map
  [remap load-theme]               #'counsel-load-theme
  [remap apropos]                  #'counsel-apropos
  [remap bookmark-jump]            #'counsel-bookmark
  [remap describe-bindings]        #'counsel-descbinds
  [remap info-lookup-symbol]       #'counsel-info-lookup-symbol
  [remap org-set-tags-command]     #'counsel-org-tag
  [remap unicode-chars-list-chars] #'counsel-unicode-char
  [remap locate]                   #'counsel-locate
  [remap describe-face]            #'counsel-describe-face
  [remap describe-function]        #'counsel-describe-function
  [remap describe-variable]        #'counsel-describe-variable
  [remap execute-extended-command] #'counsel-M-x
  [remap find-file]                #'counsel-find-file
  [remap find-library]             #'counsel-find-library
  [remap info-lookup-symbol]       #'counsel-info-lookup-symbol
  [remap imenu]                    #'counsel-imenu
  [remap recentf-open-files]       #'counsel-recentf
  [remap org-capture]              #'counsel-org-capture
  [remap evil-ex-registers]        #'counsel-evil-registers
  [remap yank-pop]                 #'counsel-yank-pop)
#+end_src

**** no sort commands
:PROPERTIES:
:ID:       a9861cab-eded-413f-939d-92b66ed32961
:END:

I specify certain commands provided by counsel that should not have their
candidates sorted.

#+begin_src emacs-lisp
(after! (counsel ivy-prescient)
  (setq ivy-prescient-sort-commands
        (-snoc ivy-prescient-sort-commands
               #'counsel-org-link
               #'counsel-org-goto
               #'counsel-yank-pop
               #'counsel-recentf
               #'counsel-buffer-or-recentf)))
#+end_src

**** counsel-org-capture-string
:PROPERTIES:
:ID: 799ac569-85e8-43c0-93ae-a00cf982777f
:END:

The default org capture templates use a text popup for selecting capture
templates. That's nice, but I'd rather be consistent and use my completing
framework for this as I do for everything else. This package that provides a
completing-read-using replacement for [[helpfn:org-capture][org-capture]] called
[[helpfn:counsel-org-capture-string][counsel-org-capture-string]].

#+begin_src emacs-lisp
(use-package! counsel-org-capture-string
  :after org ivy
  :commands counsel-org-capture-string)
#+end_src

**** counsel-web
:PROPERTIES:
:ID:       4b6f264a-1724-4fc5-8b95-54d14642c429
:END:

This package lets me search the web via ivy.

#+begin_src emacs-lisp
(use-package! counsel-web
  :commands counsel-web-suggest counsel-web-search
  :setq (counsel-web-search-dynamic-update . t))
#+end_src

*** swiper
:PROPERTIES:
:ID: 732421fb-2eb6-4701-be12-d4b03c726df8
:END:

[[https://github.com/abo-abo/swiper][Swiper]] is a package that lets you interactively search text in a buffer. For
example, [[file:./screenshots/searching-for-default-in-swiper.png][this]] is a screenshot of me searching for the word "default".

#+begin_src emacs-lisp
(use-package! swiper
  :commands swiper swiper-isearch
  :setq (swiper-action-recenter . t))
#+end_src

** company
:PROPERTIES:
:ID: 436d68f7-09f1-470a-a730-fd79d9c183ee
:END:

*** company
:PROPERTIES:
:ID: 89fcd613-f7ea-461b-a91c-0d9a0ae28093
:END:

[[https://github.com/company-mode/company-mode][company]] offers code completion.

#+begin_src emacs-lisp
(use-package! company
  :hook prog-mode
  :bind (:map company-active-map
         ([tab] . company-select-next)
         ([backtab] . company-select-previous)
         ("C-k"     . company-select-previous)
         ("C-j"     . company-select-next))
  :setq
  (company-frontends . '(company-pseudo-tooltip-frontend))
  (company-tooltip-align-annotations . t)
  (company-show-numbers . t)
  (company-dabbrev-downcase . nil)
  (company-idle-delay . 0.15)
  (company-tooltip-limit . 14)
  (company-minimum-prefix-length . 1)
  (company-minimum-prefix-length . 1)
  (company-require-match . 'never))
#+end_src

*** backends
:PROPERTIES:
:ID: 976f3260-992a-44ee-af91-5eff0b398b20
:END:

[[helpvar:company-backends][company-backends]] is what you have to keep in mind when you're using
company. According to its documentation, =company-backends= contain
individual backends or groups of backends. This is important so it's
worth quoting here:

**** backends-alist
:PROPERTIES:
:ID: 1ca376a2-e92f-4b77-8a91-3c2d00c0c5b7
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-yasnippet company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet)))
    (conf-mode :derived (company-capf company-dabbrev-code company-yasnippet))
    (org-mode  :only (company-yasnippet)))
  "An alist matching modes to company backends.")
#+end_src

**** initialize a backend
:PROPERTIES:
:ID: 24288386-3600-4a23-90d1-d38f9862aca0
:END:

#+begin_src emacs-lisp
(defhook! setup-backends (after-change-major-mode-hook :local t)
  "Set `company-backends' for the current buffer."
  (when (and (bound-and-true-p company-mode)
             (not (eq major-mode 'fundamental-mode)))
    (set (make-local-variable 'company-backends) (company--backends+))))
#+end_src

**** get backends
:PROPERTIES:
:ID: 985f9898-2608-4aa2-8ee9-98a178a4d5e5
:END:

#+begin_src emacs-lisp
(defun company--backends+ ()
  "Compute company backends."
  (or
   (-when-let (((mode type backends) (assoc major-mode company:backend-alist)))
     (when (eq type :only) backends))
   (-mapcat (-lambda ((mode type backends))
              (when (or (and (eq type :derived) (derived-mode-p mode))
                        (and (eq type :exact)
                             (or (eq major-mode mode)
                                 (and (boundp mode) (symbol-value mode)))))
                backends))
            company:backend-alist)))
#+end_src

**** local hook
:PROPERTIES:
:ID: 49a1e8e6-c557-4a9c-9a3a-a1aa60f90924
:END:

#+begin_src emacs-lisp
(after! company
  (put 'company:init-backends-h 'permanent-local-hook t))
#+end_src

*** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (void-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode)
             (eq company-mode t))
    (company-abort)
    t))
#+end_src

*** company prescient
:PROPERTIES:
:ID: df21548a-c262-4802-8e76-71a3135789cb
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package! company-prescient :hook company-mode)
#+end_src

* Email
:PROPERTIES:
:ID: b31fc41c-135d-45d9-9c05-5889d21d1cd4
:END:

In today's world communication is largely done via emails. Whether at work or at
school it's common to receive emails every day. In fact, you hear of people that
have 20,000+ emails in a particular account. Unsurprisingly, when we're getting
so many emails, it's easy to become overwhelmed. Fortunately, there are numerous
ways to read and send emails in Emacs.

** sendmail
:PROPERTIES:
:ID:       48c3332f-975d-4f22-94a8-4ccd394ca82a
:END:

#+begin_src emacs-lisp
(use-feature! sendmail
  :setq
  (send-mail-function . #'sendmail-send-it)
  (sendmail-program . (executable-find "msmtp"))
  (mail-specify-envelope-from . t))
#+end_src

** smtpmail
:PROPERTIES:
:ID: 4dc1e0a6-5441-4b3e-8b75-ed3626a59154
:END:

#+begin_src emacs-lisp
(use-feature! smtpmail
  :disabled t
  :setq
  (smtp-default-mail-server . "mail.example.com")
  (smtp-smtp-server . "mail.example.com")
  (smtpmail-smtp-service . 587)
  (smtpmail-debug-info . t))
#+end_src

** message
:PROPERTIES:
:ID:       4cf38804-18d6-470c-a9c3-e3327f2bebf9
:END:

#+begin_src emacs-lisp
(use-feature! message
  :setq
  (message-signature . user-full-name)
  (message-sendmail-envelope-from . 'header)
  (message-send-mail-function . #'sendmail-send-it)
  (message-kill-buffer-on-exit . t))
#+end_src

** mu4e
:PROPERTIES:
:ID: 1ec73e33-5b94-4199-976d-1d72f8fb5a8e
:END:

The most popular emacs mail client is =mu4e=. And, there is good reason why. =mu4e=
has many juicy features. Overall, =mu4e= is definitely a great mail client.
However, it's not all roses and rainbows; it does have a few annoying quicks.
One is that unlike virtually all other emacs packages it does not come decoupled
from =mu=. Another is that it is hard to set up multiple accounts properly despite
it's [[explicit support]] for multiple accounts. =mu4e= comes bundled with =mu=. A
significant advantage of using it is it's the most popular option and,
therefore, has the most support (in the form of setup blogs and packages).

*** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(use-package! mu4e
  :straight nil
  :ensure-system-package (mu . "yay -S mu")
  :load-path "/usr/share/emacs/site-lisp/mu4e/"
  :commands mu4e
  :setq
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-view-show-addresses . t)
  (mu4e-view-show-images . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed . t)
  (mu4e-get-mail-command . "mbsync -a")
  (mu4e-index-cleanup . t)
  (mu4e-index-lazy-check . nil)
  (mu4e-update-interval . 180)
  (mu4e-headers-auto-update . t)
  (mu4e-context-policy . 'pick-first)
  (mu4e-compose-context-policy . 'ask-if-none)
  (mu4e-confirm-quit . nil)
  (mu4e-header-fields . '((:human-date . 12)
                          (:flags . 4)
                          (:from . 25)
                          (:subject)))
  (mu4e-html2text-command . (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text)))
#+end_src

*** TODO setup mu4e
:PROPERTIES:
:ID:       8ed2fe81-eda9-4343-a6e1-0a6a725866a4
:END:

#+begin_src emacs-lisp
(defun mu4e/init ()
  "Initialize mu4e."
  (interactive)
  (require 'password-store)
  (let ((email-dirs (--map (concat VOID-EMAIL-DIR it) (pass:email-list))))
    (when (or (not (-all-p #'f-exists-p email-dirs))
              (-some-p #'f-empty-p email-dirs))
      (message "creating directories that don't exist.")
      (--each email-dirs (mkdir it t))
      (shell-command (format "mu init -m %s" VOID-EMAIL-DIR))
      (message "Updating mail...")
      (mu4e-update-mail-and-index t))))
#+end_src

*** mu4e headers
:PROPERTIES:
:ID: 8b59c5bb-180c-461e-9b1a-4a0c95cb7671
:END:

#+begin_src emacs-lisp
(use-package! mu4e-headers
  :straight nil
  :after mu4e
  :setq
  (mu4e-use-fancy-chars . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

*** org mu4e
:PROPERTIES:
:ID: 9045b0f5-af8c-481e-914e-a19c4bbf2941
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package! org-mu4e
  :disabled t
  :hook (mu4e-compose-mode . org-mu4e-compose-org-mode)
  :setq
  (org-mu4e-link-query-in-headers-mode . nil)
  (org-mu4e-convert-to-html . t)
  :config
  ;; Only render to html once. If the first send fails for whatever reason,
  ;; org-mu4e would do so each time you try again.
  (defhook! org-mu4e-render-html-only-once (message-send-hook)
    (setq-local org-mu4e-convert-to-html nil)))
#+end_src

*** multiple accounts
:PROPERTIES:
:ID: ad6de3a4-674c-490f-841e-19b8f891cd65
:END:

Mu4e certainly gave me some trouble setting up multiple accounts despite [its
attempt] to make this easy. I have one directory =~/.mail= where which stores all
my mail. The subdirectories of =~/.mail= correspond to my individual email
accounts. Until I set multiple accounts correctly it keeps prompting me to
create folders (such as =sent/=) in the =~/.mail= directory. I think part of the
reason I spent so much time setting this up is because.

**** return the list of emails with credentials
:PROPERTIES:
:ID:       3f7b1728-b855-447f-9f15-43bd79a94c14
:END:

#+begin_src emacs-lisp
(defun pass:email-list ()
  "Return a list of emails."
  (->> (password-store-list)
       (--map (elt (s-match "email/\\(.*\\)" it) 1))
       (-non-nil)))
#+end_src

**** return the stuff as a plist
:PROPERTIES:
:ID:       8129ca16-8641-4f2f-a4b6-03477d5b78f3
:END:

#+begin_src emacs-lisp
(defun pass:email-account-plist (email)
  "Return a plist of the relevant values of an email."
  (shut-up!
    (->> (cdr (password-store-parse-entry email))
         (mapcar #'car)
         (--mapcat (list (intern it)
                         (password-store-get-field (concat "email/" email) it))))))
#+end_src

**** mu4e folder name alist
:PROPERTIES:
:ID:       2ef07842-e321-4fff-ae73-f19c41d263a4
:END:

Mu4e keeps prompting you for the sent, trash, and drafts directory if you do not
assign the corresponding mu4e variables. The way certain email servers name
their directories varies. For example, outlook names its sent directory as =Sent
Items=.

#+begin_src emacs-lisp
(defun mu4e:guess-folder (base-dir possible-name &rest other-possible-names)
  "Return the first file in BASE-DIR that matches POSSIBLE-NAME or any POSSIBLE-NAMES.
If there is no match, return POSSIBLE-NAME."
  (alet (or (--first (-some-p (-cut s-contains-p <> it t)
                              (cons possible-name other-possible-names))
                     (cddr (directory-files base-dir)))
            possible-name)
    (format "/%s/%s" (f-filename base-dir) it)))
#+end_src

**** set up contexts for single account
:PROPERTIES:
:ID:       66d460d7-9647-4c29-8348-eb7b3d571630
:END:

#+begin_src emacs-lisp
(defun mu4e::account-context (email)
  "Return an mu4e account context for specified EMAIL."
  (let* ((base-dir (concat VOID-EMAIL-DIR email "/"))
         (name (cl-second (s-match ".*@\\([^.]*\\)" email)))
         (account (pass:email-account-plist email))
         (out-host (plist-get 'out-host account))
         (out-port (plist-get 'out-port account)))
    (alet `((mu4e-sent-folder      . ,(mu4e:guess-folder base-dir "sent"))
            (mu4e-drafts-folder    . ,(mu4e:guess-folder base-dir "draft"))
            (mu4e-trash-folder     . ,(mu4e:guess-folder base-dir "trash" "delete" "junk"))
            (user-email-address    . ,email)
            (smtpmail-smtp-server  . ,out-host)
            (smtpmail-smtp-user    . ,base-dir)
            (smtpmail-smtp-service . ,out-port))
      (make-mu4e-context :name name :vars it))))
#+end_src

**** multiple contexts
:PROPERTIES:
:ID: e56b64ac-ed36-4689-b8f4-8711c1f4f79f
:END:

#+begin_src emacs-lisp
(defadvice! setup-contexts (:before mu4e)
  "Initiaize context for each email account."
  (require 'password-store)
  (--each (-map #'mu4e::account-context (pass:email-list))
    (cl-pushnew it mu4e-contexts)))
#+end_src

*** shortcuts
:PROPERTIES:
:ID: 565ce4bc-2cdb-4e1a-b871-e2d7d34137de
:END:

#+begin_src emacs-lisp
(defun mu4e/view-today-emails ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "date:today..now"))

(defun mu4e/view-shnu-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis.henriquez@snhu.edu"))

(defun mu4e/view-luishp-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis@luishp.xyz"))

(defun mu4e/view-gmail-account ()
  (interactive)
  (mu4e-headers-search "to:luishenriquezperez@gmail.com"))
#+end_src

*** bindings
:PROPERTIES:
:ID: 6b7e8206-24aa-485f-87e0-98a997936205
:END:

#+begin_src emacs-lisp
(general-def 'normal mu4e-headers-mode-map
  "q" #'kill-buffer-and-window
  "i" #'ignore
  "I" #'ignore
  "D" #'mu4e-headers-mark-for-delete
  "F" #'mu4e-headers-mark-for-flag
  "u" #'mu4e-headers-mark-for-unmark
  "x" #'mu4e-mark-execute-all
  "t" #'mu4e-headers-mark-for-trash
  "c" #'mu4e-compose
  "o" #'org-mu4e-compose-org-mode
  "s" #'mu4e-headers-search
  "r" #'mu4e-compose-reply
  "RET" #'mu4e-headers-view-message)

(general-def 'normal mu4e-view-mode-map
  "q" #'kill-buffer-and-window)

(define-localleader-key! mu4e-compose-mode-map
  "s" (list :def #'message-send-and-exit :which-key "send and exit")
  "d" (list :def #'message-kill-buffer :which-key "kill buffer")
  "S" (list :def #'message-dont-send :which-key "save draft")
  "a" (list #'mail-add-attachment :which-key "attach"))
#+end_src

*** truncate lines in messages
:PROPERTIES:
:ID: e6addd49-6aa4-4b9e-8e50-4f0ea43aedb7
:END:

#+begin_src emacs-lisp
(defhook! wrap-text-in-message (mu4e-view-mode-hook)
  (setq-local truncate-lines nil))
#+end_src

** notmuch
:PROPERTIES:
:ID: 9bc1dad1-e2ec-4699-b471-a25b28aaaf26
:END:

Notmuch is probably the most elegant email solution of the three. It operates
purely on tags. Mu4e uses tags in the background but =notmuch= goes all out.
There's no concept of folders. A great thing about this is you avoid the
headache of Mu4e contexts because there is no such thing as a context to
=notmuch=. =notmuch= couldn't care less about how your emails are organized. Also,
=notmuch= is even faster than Mu4e when it comes to indexing email. Though this
probably won't be a significant practical difference unless you have *many*
emails.

*** bootstrap
:PROPERTIES:
:ID: e0cbf1d5-6e48-4a11-8f68-1151d2fc3e28
:END:

#+begin_src emacs-lisp
(use-package! notmuch
  :ensure-system-package notmuch
  :commands notmuch
  :setq
  (notmuch-search-oldest-first . nil)
  ;; Don't show notmuch logo.
  (notmuch-show-logo . nil)
  (notmuch-show-mark-read-tags . '("-unread")))
#+end_src

*** accounts
:PROPERTIES:
:ID: 5db186cb-8650-4be9-9b9a-9b001a951d35
:END:

I want this command to be a replacement to `notmuch'. Calling `notmuch'
displays an (ugly) intro screen. I find that most of the time I just want to
see my inbox, no questions asked.

#+begin_src emacs-lisp
(defun notmuch/display-inbox ()
  "Display the inbox."
  (interactive)
  (notmuch-search "tag:inbox" notmuch-search-oldest-first))

(defun notmuch/luishp-account ()
  (interactive)
  (notmuch-search "to:luis@luishp.xyz" notmuch-search-oldest-first))

(defun notmuch/luishenriquezperez-account ()
  (interactive)
  (notmuch-search "to:luishenriquezperez@gmail.com NOT tag:spam" notmuch-search-oldest-first))

(defun notmuch/snhu-account ()
  (interactive)
  (notmuch-search "to:luis.henriquez@snhu.edu"))
#+end_src

*** update mail
:PROPERTIES:
:ID: e98aae10-ae2f-479b-97b5-2a84a202e5fe
:END:

#+begin_src emacs-lisp
(defun notmuch/update ()
  (interactive)
  (start-process-shell-command
   "notmuch update" nil
   "mbsync -a && notmuch new")
  ;; (notmuch-tag "tag:new and folder:luishenriquezperez@gmail.com/spam" '("+spam" "-new" "-unread"))
  ;; tag new spam email as spam.
  ;; mark new email as new.
  )
#+end_src


** gnus                                                               :disabled:
:PROPERTIES:
:ID: d9ce252d-5f33-469b-a88c-84131f6f0eaa
:END:

Perhaps the least popular way of using emails is using gnus. It is actually how
[[][John Wiegley]], one of Emacs's maintainers, has managed his email for over
20 years. Gnus is really a mixed bag. One the one hand, I absolutely love the
fact that it's written in pure elisp (making it extremely customizable) and that
it's built-in to emacs. You can be on a completely different computer and set up
have a working client with just Emacs--that's pretty incredible. On the other
hand, the abstraction it is based on is extremely outdated making many of it's
variables and functions more difficult to understand (just by reading their
name) than normal; and it's pretty slow when dealing with many emails (by many I
mean 2000 which is not a lot by today's standard).

*** bootstrap
:PROPERTIES:
:ID: 80d3161d-0d0d-4c34-abf7-5ca12501f16c
:END:

#+begin_src emacs-lisp
(use-feature! gnus
  :commands gnus
  :setq
  (gnus-summary-line-format "%U%R%z %-16,16&user-date; %-30,30f  %B%S\n")
  (gnus-select-method . '(nnnil))
  (gnus-agent . t)
  (gnus-agent-article-alist-save-format . 1)
  (gnus-agent-cache . t)
  (gnus-agent-confirmation-function . 'y-or-n-p)
  (gnus-agent-consider-all-articles .  nil)
  (gnus-agent-directory . "~/News/agent/")
  (gnus-agent-enable-expiration . 'ENABLE)
  (gnus-agent-expire-all . nil)
  (gnus-agent-expire-days . 30)
  (gnus-agent-mark-unread-after-downloaded . t)
  (gnus-agent-queue-mail . t)
  (gnus-agent-synchronize-flags . nil))
#+end_src

*** gnus start
:PROPERTIES:
:ID: fe201237-301d-4b52-b24e-b16eb37aa31d
:END:

#+begin_src emacs-lisp
(use-feature! gnus-start
  :after gnus
  :setq
  (gnus-use-dribble-file . nil)
  (gnus-always-read-dribble-file . nil))
#+end_src

*** gnus sum
:PROPERTIES:
:ID: e16c4665-d404-49df-9cee-fec2a159e1c1
:END:

#+begin_src emacs-lisp
(use-package! gnus-sum
  :setq
  (gnus-user-date-format-alist . '(((gnus-seconds-today) . "Today at %R")
                                   ((+ 86400 (gnus-seconds-today)) . "Yest. at %R")
                                   (t . "%m-%d %R")))
  (gnus-sum-thread-tree-false-root . "")
  (gnus-sum-thread-tree-indent . " ")
  (gnus-sum-thread-tree-leaf-with-other . "├─➤ ")
  (gnus-sum-thread-tree-root . "")
  (gnus-sum-thread-tree-single-leaf . "└─➤ ")
  (gnus-sum-thread-tree-vertical . "│"))
#+end_src

*** accounts
:PROPERTIES:
:ID: 87d48ed6-cf36-4aa0-8d6d-1615ebb6a4cf
:END:

**** luis
:PROPERTIES:
:ID: fd91766f-36ec-4a13-ae90-44eaa930f58a
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "luis"
     (nnimap-address "mail.luishp.xyz")
     (nnimap-stream ssl)
     (nnimap-authenticator 'login)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '(nnmaildir "luis"
    (directory "~/.mail/luis@luishp.xyz")))
#+end_src

**** snhu
:PROPERTIES:
:ID: 620f1fcd-e5c8-42b9-a117-87e704b188af
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "school"
     (nnimap-address "outlook.office365.com")
     (nnimap-stream ssl)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '((nnmaildir "snhu"
     (directory "~/.mail/luis.henriquez@snhu.edu/"))))
#+end_src

**** gmail
:PROPERTIES:
:ID: a76bea4c-7922-4b63-9e74-d377eb943e88
:END:

#+begin_src emacs-lisp
(append! gnus-secondary-select-methods
  '(nnimap "gmail"
    (nnimap-address "imap.gmail.com")
    (nnimap-stream ssl)
    (nnimap-log-command "pass")))
#+end_src

*** gnus group
:PROPERTIES:
:ID: 1f022c0d-6157-4ba3-9676-860ef8c00258
:END:

#+begin_src emacs-lisp
(use-feature! gnus-group
  :setq
  (gnus-group-line-format . "%M\ %S\ %p\ %P\ %5y:%B%(%g%)\n"))
#+end_src

*** gnus art
:PROPERTIES:
:ID: 1642c04a-5332-484b-81e5-36bd16ca69a0
:END:

#+begin_src emacs-lisp
(use-package! gnus-art
  :after gnus
  :setq
  (gnus-article-browse-delete-temp . 'ask)
  (gnus-article-over-scroll . nil)
  (gnus-article-show-cursor . t)
  (gnus-article-sort-functions
   '(gnus-article-sort-by-most-recent-number
     gnus-article-sort-by-most-recent-date))
  (gnus-article-truncate-lines . nil)
  ;; (gnus-html-frame-width 80)
  ;; (gnus-html-image-automatic-caching t)
  (gnus-inhibit-images . t)
  (gnus-max-image-proportion . 0.3)
  (gnus-treat-display-smileys . nil)
  ;; (gnus-article-mode-line-format "%G %S %m")
  (gnus-visible-headers
   '("^From:" "^To:" "^Cc:" "^Newsgroups:" "^Subject:" "^Date:"
     "Followup-To:" "Reply-To:" "^Organization:" "^X-Newsreader:"
     "^X-Mailer:"))
  (gnus-sorted-header-list . gnus-visible-headers))
#+end_src

* Web Browsing
:PROPERTIES:
:ID: f0960e47-5dbb-4cca-a17a-f8eb0da445d3
:END:

In current times we are fortunate enough to have a wealth of information
available to us only a web search away.

** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

*** w3m
:PROPERTIES:
:ID: 10ddb49f-9280-49f4-8ca4-c46310d8a1dd
:END:

#+begin_src emacs-lisp
(use-package! w3m
  :ensure-system-package w3m
  :commands w3m
  :setq (w3m-search-default-engine . "google"))
#+end_src

*** traversing
:PROPERTIES:
:ID: aded77d8-8088-4aad-b0b9-bb5a45d343f2
:END:

#+begin_src emacs-lisp
(general-def 'normal w3m-mode-map
  "o" #'w3m-search
  "O" #'w3m-search-new-session
  ;; Jump to a link with avy in the current session.
  "f" #'ace-link-w3m
  "F" #'ace-link-open-new-session
  ;; Delete the current emacs-w3m buffer and switch to the previous one.
  "D" #'w3m-delete-buffer
  ;; Move through tabs.
  "J" #'w3m-tab-move-right
  "K" #'w3m-tab-move-left
  ;; Move back COUNT pages in the history.
  "H" #'w3m-view-previous-page
  ;; Move forward COUNT pages in history.
  "L" #'w3m-view-next-page)
#+end_src

** browse-url
:PROPERTIES:
:ID:       92e4183b-0fbf-44fa-a939-3f8e017deb4f
:END:

*** qutebrowser
:PROPERTIES:
:ID:       3277cd4e-01ce-40da-9d1e-9bf167d92aef
:END:

#+begin_src emacs-lisp
(use-package! browse-url
  :setq
  (browse-url-firefox-arguments . (list "--new-window"))
  (browse-url-browser-function . (list (cons "." #'browse-url-firefox))))
#+end_src

* Multimedia
:PROPERTIES:
:ID: 20a915a0-8525-413c-bd68-f1d5c14ce3da
:END:

I'm using "multimedia" here as an umbrella term for non-text sources of
information such as music, videos, images, and gifs.

** youtube
:PROPERTIES:
:ID: 10642631-365c-46b4-ad29-e28e509aa1ae
:END:

*** ytel
:PROPERTIES:
:ID:       167bc712-5552-4cfe-83ce-d0bb9927fa6a
:END:

=ytel= is a YouTube search front-end. It is designed to let the user collect
YouTube search results into a buffer and manipulate them with emacs lisp.

#+begin_src emacs-lisp
(use-package! ytel
  :ensure-system-package (youtube-dl curl)
  :commands ytel
  :setq (ytel-invidious-api-url . "https://invidious.snopyta.org"))
#+end_src

*** watch video
:PROPERTIES:
:ID:       547c6d1d-c8a5-42b3-8000-029228923304
:END:

#+begin_src emacs-lisp
(defun ytel/watch ()
  "Stream video at point in mpv."
  (interactive)
  (let* ((video (ytel-get-current-video))
     	 (id    (ytel-video-id video)))
    (start-process "ytel mpv" nil
		           "mpv"
		           (concat "https://www.youtube.com/watch?v=" id))
	"--ytdl-format=bestvideo[height<=?720]+bestaudio/best")
  (message "Starting streaming..."))
#+end_src

*** download music
:PROPERTIES:
:ID:       7c28f457-3a63-45a7-87bc-dc5232a5a5cd
:END:

#+begin_src emacs-lisp
(defun ytel/download-music ()
  "Download youtube video from `ytel' interface."
  (interactive)
  (let* ((video (ytel-get-current-video))
         (title (ytel-video-title video))
         (id (ytel-video-id video))
         (dir VOID-MUSIC-DIR)
         (url (format "https://www.youtube.com/watch?v=%s" id)))
    (async-shell-command (format "cd %s && youtube-dl -f bestaudio %s" dir url))
    (message "Downloading music...")))
#+end_src

** emms
:PROPERTIES:
:ID: 5d1abf3e-d0e5-4074-8d06-2b6eba47c6e4
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

*** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package! emms
  :commands (emms emms-play-directory emms-play-file)
  :trigger emms-player-mpv
  :setq
  (emms-directory . (concat VOID-DATA-DIR "emms/"))
  (emms-seek-seconds . 5)
  (emms-player-list . '(emms-player-mpv))
  (emms-source-file-default-directory . VOID-MUSIC-DIR)
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-playlist-buffer-name . "*EMMS-PLAYLIST*")
  (mpc-host . "127.0.0.1:6600"))
#+end_src

*** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(after! emms
  (defhook! quit-emms (kill-emacs-hook)
    "Shut down EMMS."
    (when emms-player-playing-p (emms-pause))
    (emms-stop)
    ;; kill any existing mpd processes
    (when (member 'emms-player-mpd emms-player-list)
      (call-process "killall" nil nil nil "mpd"))))
#+end_src

** screenshot
:PROPERTIES:
:ID: 0038e1ed-ac6a-4529-9ecd-dfa8a44d40c9
:END:

Pictures or GIFs of behaviors can relate emacs behaviors in away descriptions
cannot. From my experience looking at posts on [[https://emacs.stackexchange.com/][emacs stackexchange]] or [[https://www.reddit.com/r/emacs/][emacs-reddit]] or
even other [[https://github.com/caisah/emacs.dz][emacs configs]], screenshots are underutilized (or often not
utilized at all). In Void, where documentation is *very* important, I supplement
my description of problems with pictures.

*** screenshot cairo
:PROPERTIES:
:ID:       d979ca37-e4e4-4205-bb94-b1ad6cfe1651
:END:

If emacs 27 has been compiled with Cairo support, it can take screenshots. I
adapted this example from [[https://github.com/caiohcs/my-emacs][caiohcs's emacs]].

#+begin_src emacs-lisp
(defun void/take-screenshot ()
  "Take a screenshot and save it in `VOID-MULTIMEDIA-DIR'."
  (let* ((entered-name (read-string "Image Name: "))
         (default-name (format "image-%s" (ts-format)))
         (image-name (if (string-empty-p entered-name) default-name entered-name))
         (filename (format "%s%s.svg" VOID-MULTIMEDIA-DIR image-name))
	     (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message "%s -> %s" (f-filename filename) VOID-MULTIMEDIA-DIR)))
#+end_src

*** screenshot
:PROPERTIES:
:ID: c0975eae-c03b-4d2a-a546-06c05197eded
:END:

[[][]] is another emacs screenshot package that.

#+begin_src emacs-lisp
(use-package! screenshot :commands screenshot)
#+end_src

*** escr                                                              :disabled:
:PROPERTIES:
:ID:       06f23fc2-7f6b-4812-a14d-185b42a42976
:END:

#+begin_src emacs-lisp
(use-package! escr :disabled t)
#+end_src

*** scrot
:PROPERTIES:
:ID: 325935aa-b0f1-49b6-8c67-1173c5a1d42b
:END:

Like [[][screenshot]], [[https://github.com/dakra/scrot.el][scrot]] is screenshot taking utility. Interestingly, scrot
has a function that can capture a screenshot of a particular emacs window.

#+begin_src emacs-lisp
(use-package! scrot :straight (:host github :repo "dakra/scrot.el"))
#+end_src

** gifs
:PROPERTIES:
:ID: 28387a67-7037-47ce-97c9-c35d77f7cb22
:END:

This package allows for the creation of gifs from within emacs.

#+begin_src emacs-lisp
(use-package! gif-screencast)
#+end_src

** keypression                                                        :disabled:
:PROPERTIES:
:ID: 1943c432-4d47-43a5-ba92-2f17205bbae0
:END:

[[https://github.com/chuntaro/emacs-keypression][keypression]] is displays keypresses from within Emacs--no external tools
necessary! It [[https://raw.githubusercontent.com/wiki/chuntaro/emacs-keypression/images/screencast.gif][looks]] pretty professional!

#+begin_src emacs-lisp
(use-package! keypression
  :straight (:host github :repo "chuntaro/emacs-keypression")
  :setq (keypression-frame-justify . 'keypression-right-justified))
#+end_src

* Text Editing
:PROPERTIES:
:ID: 42e0838f-f72a-43f3-8db2-a406d2d89adb
:END:

** highlight-numbers
:PROPERTIES:
:ID: d6e3227c-7678-47f0-95a8-3a6fda1638d6
:END:

What [[https://github.com/Fanael/highlight-numbers][highlight-numbers]] does is pretty self explanatory: it highlights numbers.

#+begin_src emacs-lisp
(use-package! highlight-numbers
  :hook (prog-mode conf-mode)
  :setq (highlight-numbers-generic-regexp . "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))
#+end_src

** highlight-escape-sequences                                         :disabled:
:PROPERTIES:
:ID: 608d94c5-806f-4303-bb81-0b95a3dfcacc
:END:

Also pretty self explanatory is [[https://github.com/dgutov/highlight-escape-sequences][highlight-escape-sequences]].

#+begin_src emacs-lisp
(use-package! highlight-escape-sequences
  :ensure (:host github :repo "hlissner/highlight-escape-sequences")
  :hook (prog-mode conf-mode))
#+end_src

** hideshow
:PROPERTIES:
:ID: 915f65c3-8121-4480-b246-f190fe117950
:END:

Hiding text can be extremely useful. It is something that's used extensively in
Org Mode. The feature responsible for doing this is [[][hideshow]].

#+begin_src emacs-lisp
(use-package! hideshow
  :hook (prog-mode . hs-minor-mode)
  :commands hs-minor-mode hs-toggle-hiding hs-already-hidden-p
  :setq (hs-hide-comments-when-hiding-all . nil))
#+end_src

** rainbow-delimiters
:PROPERTIES:
:ID: c771a943-593f-4119-8754-9d7e5da4466b
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package! rainbow-delimiters
  :hook (prog-mode reb-mode-hook)
  :setq (rainbow-delimiters-max-face-count . 9))
#+end_src

** edit-indirect
:PROPERTIES:
:ID: 82e6a83b-f238-46e1-bcc2-a23bddf412be
:END:

Edit indirect is a package that allows me to edit a region from one buffer in a
different buffer. If know about [[info:org#Summary][org-mode]] and [[info:org#Working with Source Code][source blocks]], this should
sound familiar. There are two major reasons for me why doing this kind of
editing has advantages over just editing the original buffer as is. One is that
it eases cognitive effort by allowing you to focus on one bite-sized region of a
buffer instead the whole thing. The second is that it allows you apply
specialized modes to a region that may not be appropriate for the buffer as a
whole. I use this package for editing source blocks instead of [[helpfn:org-edit-src-code][org-edit-src-code]]
mainly for consistency.

*** edit-indirect
:PROPERTIES:
:ID: 4da94b9a-9e3b-4e3b-8f56-d574969cb812
:END:

#+begin_src emacs-lisp
(use-package! edit-indirect
  :before-call (org/edit:description-at-point org/dwim-edit-source-block)
  :popup ("\\*edit-indirect"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (slot . 10)))
#+end_src

*** list of headline elements
:PROPERTIES:
:ID: 3d77c526-1061-4a91-998b-06b4c3d5b48b
:END:

Striving to edit org buffers as functionally as possible as opposed to using
side-effects is very important. It makes code easier and less error prone to
write because you deal with actual lisp object as opposed to less tangible
buffer text. It also makes code easier to debug because you can test for the
correctness of values returned as opposed to the state change of the buffer.

#+begin_src emacs-lisp
(cl-defun org:element-headline-elements ()
  "Return the list of org elements from the current headline to the next."
  (save-excursion
    (unless (org-at-heading-p) (org-back-to-heading))
    (unless (org-at-heading-p) (cl-return))
    (cons (org-element-at-point)
          (ignore-errors
            (org-down-element)
            (--unfold (when (ignore-errors (org-forward-element))
                        (cons it (org-element-at-point)))
                      (org-element-at-point))))))
#+end_src

*** editing headline descriptions
:PROPERTIES:
:ID: 84867fc3-0808-437a-8037-5ab8e2e2b24e
:END:

As I've [[][mentioned]], Org mode provides syntax to systematically delineate
different languages from one another. Editing the contents of these languages is
typically done through the use of [[helpfn:org-edit-src-code][org-edit-src-code]] (although I do it via
[[helpfn:edit-indirect-region][edit-indirect-region]]). =org-edit-src-code= provides a convenient and elegant way
to edit these languages. It pop open a buffer with the contents of the source block.

However, as I will argue there's one "language" which does not require source
block syntax separation in org mode and that is plain text. In org mode, plain
prose is typically utilized to describe the contents of a headline just as I'm
doing right now. While (I think at least) it is technically not differentiated
from org mode syntax.

However, org mode does not go far enough. If you think about it descriptions
under headlines are also in a "different language"--they're in plain prose. And
this is different from org-mode syntax. They utilize a different editing style
and require different modes from org-mode.

**** whether an element is a paragraph
:PROPERTIES:
:ID: 8f23f8e6-cd9e-4da2-872d-8413fbe2773b
:END:

This function isn't necessary. However, it's very convenient to abbreviate ~(eq
(org-element-type elt) 'paragraph)~--more so because it's a check I perform all
the time.

#+begin_src emacs-lisp
(defun org:element-paragraph-p (element)
  "Return non-nil if the current element is a paragraph."
  (eq (org-element-type element) 'paragraph))
#+end_src

**** point in org element
:PROPERTIES:
:ID: 73a096e6-93d2-4c68-b02f-c31e66cfece5
:END:

#+begin_src emacs-lisp
(defun org:element-contains-point-p (point element)
  "Return t if POINT is inside ELEMENT."
  (and (>= point (org-element-property :begin element))
       (>= (org-element-property :end element) point)))
#+end_src

**** paragraph bounds
:PROPERTIES:
:ID: a049f3ec-8936-499b-af03-e6f4be22163b
:END:

#+begin_src emacs-lisp
(defun org:edit-desc-bounds (point elements)
  "Return the bounds of the description at point.
ELEMENTS is a list of headline elements (see `org:element-headline-elements')."
  (awhen (-find (-some-p (-partial #'org:element-contains-point-p point) it)
                (->> (cdr elements)
                     (-group-by #'org:element-paragraph-p)
                     (-filter (-compose #'org:element-paragraph-p #'car))))
    (cons (org-element-property :contents-begin (-first-item it))
          (org-element-property :contents-end (-last-item it)))))
#+end_src

**** org edit description at point
:PROPERTIES:
:ID: d37dd016-d5ec-4524-974d-d157bba231fc
:END:

#+begin_src emacs-lisp
(defun org/edit:description-at-point ()
  "Edit the description at point."
  (interactive)
  (-when-let ((beg . end) (org:edit-desc-bounds (point) (org:element-headline-elements)))
    (edit-indirect-region beg end t)))
#+end_src

**** dwim paragraph bounds
:PROPERTIES:
:ID: 8c321bbc-d6ee-42d6-90f5-ff8b9106c51b
:END:

I don't want to have to travel to a description to edit it. Ideally, I'd like to
travel to anywhere I need within a heading from the headline itself.

#+begin_src emacs-lisp
(defun org:dwim-description-bounds (point elements)
  "Return bounds description under headline as a cons cell.
If there is no description element, return a cons cell containing the the point
where the point should go."
  ;; There are no paragraph elements.
  (acond ((-any-p #'org:element-paragraph-p elements)
          (alet (->> elements
                     (-partition-by #'org:element-paragraph-p)
                     (-filter (-compose #'org:element-paragraph-p #'-first-item))
                     (-first-item))
            (cons (org-element-property :contents-begin (-first-item it))
                  (org-element-property :contents-end (-last-item it)))))
         ;; Is there a source block?
         ((--first (eq (org-element-type it) 'src-block) elements)
          (cons (org-element-property :begin it)
                (org-element-property :begin it)))
         ;; Insert it after the last headline element.
         ((org-element-property :end (-last-item elements))
          (cons it it))))
#+end_src

**** maybe add newlines
:PROPERTIES:
:ID: 476da722-8530-4652-821d-77cdd4869680
:END:

Edit indirect has two hooks (four if you include == ==). This is great! The
problem is that you will likely use =edit-indirect= for various different
things. And for these different things, you might want to use different hooks
(i.e. a hook for editing a comment in an =edit-indirect= buffer might not be
appropriate for editing a source block.) You don't want the hooks stepping over
eachother.

The best way I could think of achieving this is through temporary or transient
hooks.

#+begin_src emacs-lisp
(defun edit:indirect-add-newlines-maybe-h ()
  "Add newlines to edit-indirect buffer before commiting."
  (when (aand edit-indirect--overlay
              (= (overlay-start it) (overlay-end it)))
    (add-hook 'edit-indirect-before-commit-hook
              (lambda ()
                ;; (not (string-match-p "\\(?:[[:space:]]\\|\n\\)+" (buffer-string)))
                (goto-char (point-max)) (insert "\n\n"))
              0
              :local)))
#+end_src

**** dwim edit description
:PROPERTIES:
:ID: b409f0d6-c681-4554-9ee5-2a303bd613b3
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  "Edit a description the way I want to."
  (interactive)
  (-let* ((elements (org:element-headline-elements))
          ((beg . end) (org:dwim-description-bounds (point) elements))
          (edit-indirect-guess-mode-function (lambda (&rest _) (text-mode)))
          (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
    (edit-indirect:add-before-commit-hook #'edit-indirect:ensure-newline)
    (general-add-hook 'edit-indirect-after-creation-hook
                      ;; Move point to last non-whitespace character.
                      (list (lambda ()
                              (end-of-buffer)
                              (ignore-errors (re-search-backward (rx (or white "\n")))))
                            #'evil-insert-state))
    (edit-indirect-region beg end t)))
#+end_src

**** org link minor mode                                              :disabled:
:PROPERTIES:
:ID: 7af9c8bb-f3ad-43a1-8c9b-aeac6a4fdb36
:END:

#+begin_src emacs-lisp
(use-package! org-link-minor-mode
  :commands org-link-minor-mode)
#+end_src

*** editing source blocks
:PROPERTIES:
:ID: c6269fa0-936c-4daf-8803-a4caea3955ef
:END:

Why use this package to edit source blocks when there's already an org function
which does it? One reason is consistently. Eventually, I want all separate
editing buffers to be from =edit-indirect=. That why I don't have to configure
both =edit-indirect= and org source block function to work the way I want; I can
deal with just one source.

**** add before commit hook
:PROPERTIES:
:ID:       ab108485-1978-4bfd-9329-cc29035399d2
:END:

#+begin_src emacs-lisp
(defun edit-indirect:add-before-commit-hook (fn)
  "Add FN."
  (add-hook 'edit-indirect-after-creation-hook
            `(lambda ()
               (add-hook 'edit-indirect-before-commit-hook #',fn nil t))))
#+end_src

**** prevent ending with no newline
:PROPERTIES:
:ID: 9ac56ec5-5fbd-4b5c-bd24-eac81b3b196b
:END:

=edit-indirect= buffers with source block contents must end in a newline
otherwise the =#+end_src= code block delimiter will not end up in its own line
(see this for example).

#+begin_src emacs-lisp
(defun edit-indirect:ensure-newline (&optional block-was-empty-p)
  "Ensure that source block ends with a newline.
If the source block was initially empty and no content was added, don't add a newline.
Otherwise, add a newline if there isn't one."
  (save-excursion
    (when (and (not (string-match-p (rx (* anything) "\n" eos) (buffer-string)))
               (not block-was-empty-p))
      (goto-char (point-max))
      (insert "\n"))))
#+end_src

**** edit source block at point
:PROPERTIES:
:ID: 786a9971-d0de-4a1a-81e8-82617bdfe88e
:END:

#+begin_src emacs-lisp
(defun org/edit-source-block-at-point ()
  "Edit the source block at point."
  (interactive)
  (alet (org-element-context)
    (when (or (null it) (not (eq 'src-block (org-element-type it))))
      (user-error "No element at point."))
    (-let* (((beg end) (org-src--contents-area it))
            (lang (plist-get (-second-item it) :language))
            (edit-indirect-guess-mode-function `(lambda (&rest _) (funcall (org-src-get-lang-mode ,lang))))
            (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
      (add-hook 'edit-indirect-after-creation-hook #'edit-indirect:ensure-newline)
      (add-hook 'edit-indirect-after-creation-hook #'beginning-of-buffer)
      (edit-indirect-region beg end t))))
#+end_src

**** dwim edit source block
:PROPERTIES:
:ID: 195b3fdf-4bea-40e7-9ad2-3621e4de3ddb
:END:

I want to be able to edit a source block without actually going to the source
block.

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit the source block."
  (interactive)
  (unless (org-in-src-block-p)
    (aif (--first (eq (org-element-type it) 'src-block)
                  (org:element-headline-elements))
        (goto-char (org-element-property :begin it))
      (user-error "No source at headline.")))
  (org/edit-source-block-at-point))
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key! edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

*** org bindings
:PROPERTIES:
:ID: cc9b15f0-3abe-4189-b43b-a70b1f4b215f
:END:

#+begin_src emacs-lisp
(after! (evil edit-indirect)
  (evil-make-overriding-map edit-indirect-mode-map 'normal))

(define-localleader-key! org-mode-map
  "d" #'org/dwim-edit-description
  "e" #'org/dwim-edit-source-block)
#+end_src


** spacing and indentation
:PROPERTIES:
:ID: 4f5e0d70-fe6d-4dda-8949-8154464160e1
:END:

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package! aggressive-indent
  :hook emacs-lisp-mode)
#+end_src

*** electric indent
:PROPERTIES:
:ID: 4f7e6aa4-be34-4cdd-a2a8-63df24da44a1
:END:

#+begin_src emacs-lisp
(use-package! electric
  :config
  (electric-indent-mode -1))
#+end_src

*** ws-bulter
:PROPERTIES:
:ID: 7e0c30ea-a109-4176-a92b-4a1de4922032
:END:

[[https://github.com/lewang/ws-butler][ws-butler]] cleans up whitespace.

#+begin_src emacs-lisp
(use-package! ws-butler
  :hook (prog-mode org-mode)
  :config
  (append! ws-butler-global-exempt-modes
    '(special-mode comint-mode term-mode eshell-mode)))
#+end_src

*** ialign
:PROPERTIES:
:ID: 55570266-36e8-426e-aef6-5005bce6d73b
:END:

Package [[https://github.com/mkcms/interactive-align][ialign]] lets me use regular expressions to align text.

#+begin_src emacs-lisp
(use-package! ialign :commands ialign)
#+end_src

** lisp editing
:PROPERTIES:
:ID: f616348a-ba44-44f6-aeb6-3dc0a312143e
:END:

*** smartparens
:PROPERTIES:
:ID: 17257f23-c45e-4b7b-a3b4-7fd2333edf4d
:END:

**** bootstrap
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(use-package! smartparens
  :hook (prog-mode eshell-mode ielm-mode)
  :setq
  (sp-highlight-pair-overlay . nil)
  (sp-highlight-wrap-overlay . nil)
  (sp-highlight-wrap-tag-overlay . nil)
  (sp-show-pair-from-inside . t)
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-show-pair-delay . 0.1)
  (sp-max-pair-length . 4)
  (sp-max-prefix-length . 50)
  (sp-escape-quotes-after-insert . nil)
  :config
  (sp-local-pair 'emacs-lisp-mode "<" ">")
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

**** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
  "Disable smartparents skip match feature."
  (setq sp-navigate-skip-match nil)
  (setq sp-navigate-consider-sgml-tags nil))
#+end_src

**** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer, during `eval-expression' or
`evil-ex'."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

*** lispyville
:PROPERTIES:
:ID: 9d22714a-086d-49a1-9f8b-66da3b646110
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** initialize
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :commands lispyville-comment-or-uncomment-line
  :hook emacs-lisp-mode
  :bind
  (:map emacs-lisp-mode-map
   ([remap evil-yank]                 . lispyville-yank)
   ([remap evil-delete]               . lispyville-delete)
   ([remap evil-change]               . lispyville-change)
   ([remap evil-yank-line]            . lispyville-yank-line)
   ([remap evil-delete-line]          . lispyville-delete-line)
   ([remap evil-change-line]          . lispyville-change-line)
   ([remap evil-delete-char]          . lispyville-delete-char-or-splice)
   ([remap evil-delete-backward-char] . lispyville-delete-char-or-splice-backwards)
   ([remap evil-substitute]           . lispyville-substitute)
   ([remap evil-change-whole-line]    . lispyville-change-whole-line)
   ([remap evil-join]                 . lispyville-join)))
#+end_src

**** text objects
:PROPERTIES:
:ID: d553eee0-9b35-4a7d-a048-0f4a550b2471
:END:

#+begin_src emacs-lisp
(general-def evil-inner-text-objects-map
  "a" #'lispyville-inner-atom
  "l" #'lispyville-inner-list
  "x" #'lispyville-inner-sexp
  "c" #'lispyville-inner-comment
  ;; "f" #'lispyville-inner-function
  ;; "c" #'evilnc-inner-comment
  ;; overriding inner-sentence.
  "s" #'lispyville-inner-string)

(general-def evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  ;; "f" #'lispyville-a-function
  ;; "c" #'evilnc-outer-commenter
  ;; "c" #'evilnc-outer-commenter
  "s" #'lispyville-a-string)
#+end_src

**** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(general-def 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

**** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =void-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
#+end_src

**** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(general-def '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

*** lispy
:PROPERTIES:
:ID: 4b4bfc73-e4e3-44f0-9553-61ac5182c946
:END:

For learning how to use lispy. [[https://github.com/abo-abo/lispy][the README]] and the [[http://oremacs.com/lispy/#lispy-different][lispy function reference]] were
very useful to me.

#+begin_src emacs-lisp
(use-package! lispy
  :hook emacs-lisp-mode
  :setq
  (lispy-avy-style-paren . 'at-full)
  (lispy-eval-display-style . 'overlay)
  (lispy-safe-delete . t)
  (lispy-safe-copy . t)
  (lispy-safe-paste . t)
  (lispy-safe-actions-no-pull-delimiters-into-comments . t)
  (lispy-delete-sexp-from-within . t)
  (lispy-parens-only-left-in-string-or-comment . nil)
  ;; TODO see how performant is at larger thresholds and optimize
  (lispy-safe-threshold . 5000)
  (lispy-use-sly . t)
  ;; allow space before asterisk for headings (e.g. ";; *")
  (lispy-outline . "^;;\\(?:;[^#]\\|[[:space:]]*\\*+\\)")
  (lispy-key-theme . nil)
  :config
  ;; You'll get void variable if you don't do this.
  (after! avy (setq lispy-avy-keys avy-keys)))
#+end_src

** writing
:PROPERTIES:
:ID: 27e382d7-5735-4f33-87c8-3dec2d2ca082
:END:

*** spell-number
:PROPERTIES:
:ID: 9cc794c5-dc10-4fb5-8af1-dd555c749071
:END:

#+begin_src emacs-lisp
(use-package! spell-number
  :setq
  (spelln-language . 'english-us)
  (spelln-country . 'united-states)
  (spelln-period-character . ?,)
  (spelln-decimal-character . ?.))
#+end_src

*** fill paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

#+begin_src emacs-lisp
(use-package! aggressive-fill-paragraph)
#+end_src

*** spell check
:PROPERTIES:
:ID: fc68d949-246f-43bf-85c2-7fbb947af7e9
:END:

#+begin_src emacs-lisp
(use-package! spell-fu
  :straight (:host gitlab :repo "ideasman42/emacs-spell-fu")
  :commands spell-fu-mode
  :setq (spell-fu-directory . (concat VOID-DATA-DIR "spell-fu/")))
#+end_src

*** autocapitalize
:PROPERTIES:
:ID: 35c7c4c0-5009-43d6-8c34-43d6111ceb28
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package! auto-capitalize
  :setq (auto-capitalize-words . '("I" "English")))
#+end_src

*** thesaurus
:PROPERTIES:
:ID: 5578aaf2-796f-4006-af60-de87b215120a
:END:

#+begin_src emacs-lisp
(use-package! powerthesaurus
  :commands
  powerthesaurus-lookup-word-at-point
  power-thesaurus-lookup-word-dwim)
#+end_src

*** dictionary
:PROPERTIES:
:ID: 9ddc66c9-87be-43d1-8366-1bdb40718892
:END:

#+begin_src emacs-lisp
(use-package! define-it
  :commands define-it define-it-at-point
  :setq
  (define-it-output-choice . 'view)
  (define-it-show-google-translate . nil))
#+end_src

*** plural
:PROPERTIES:
:ID:       71162148-f2ee-4f38-a2bf-eede4ed17762
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~()~ returns ~"geese"~.

#+begin_src emacs-lisp
(use-package plural
  :commands (plural-make-plural))
#+end_src

** evil
:PROPERTIES:
:ID: 73366b3e-7438-4abf-a661-ed1553b1b8df
:END:

*** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

**** evil
:PROPERTIES:
:ID: 7dba80e1-58d6-46d2-a0e3-64c535e556e2
:END:

#+begin_src emacs-lisp
(use-package! evil
  :demand t
  :hook window-setup
  ;; :custom
  ;; (evil-want-C-u-scroll    . t)
  ;; (evil-want-C-d-scroll    . t)
  ;; (evil-want-C-w-delete    . t)
  ;; (evil-want-Y-yank-to-eol . t)
  ;; (evil-overriding-maps    . nil)
  ;; (evil-want-minibuffer    . t)
  :pre-setq
  (evil-want-keybinding                 . nil)
  :setq
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-want-visual-char-semi-exclusive . t)
  ;; Whether the cursor can move past the end of the line.
  (evil-move-beyond-eol                 . nil)
  (evil-magic                           . t)
  (evil-echo-state                      . nil)
  (evil-indent-convert-tabs             . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-mode-line-format                . nil)
  (evil-respect-visual-line-mode        . t)
  (evil-symbol-word-search              . t)
  (shift-select-mode                    . nil))
#+end_src

**** cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

***** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Evil differentiates what state you're in based on the cursor color.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

***** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:void-after-load-theme-hook][void-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (void-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

**** normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default `evil-mode' state."
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! replace-motion-with-normal (:around evil-make-overriding-map)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (-let (((keymap state copy) <args>))
    (funcall <orig-fn> keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! replace-motion-with-normal (:around evil-set-initial-state)
  (-let (((mode state) <args>))
    (funcall <orig-fn> mode (if (eq state 'motion) 'normal state))))

(void-add-advice #'evil-motion-state :override #'evil-normal-state)
#+end_src

**** insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

**** escape
:PROPERTIES:
:ID:       e4b9d33d-c64d-47ef-9bff-baa80d1b34b2
:END:

***** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-def :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'void-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

***** keychord integration
:PROPERTIES:
:ID:       33fa6402-f56e-4bea-a9b5-bd5a6f44792f
:END:

Sometimes we don't have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press =jk= really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package! key-chord
  :after-call evil-insert-state evil-emacs-state
  :config
  (quiet! (key-chord-mode 1))
  (general-def :states '(visual insert)
    (general-chord "jk") 'evil-force-normal-state
    (general-chord "kj") 'evil-force-normal-state))
#+end_src

**** saving
:PROPERTIES:
:ID: 8181807e-9811-427c-beec-f380d91040f9
:END:

#+begin_src emacs-lisp
(setq save-silently t)

(defun evil:save-message ()
  (message "\"%s\" %dL, %dC written"
           (buffer-name)
           (count-lines (point-min) (point-max))
           (buffer-size)))
#+end_src

**** text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

***** general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

***** fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

**** package specific setup                                           :disabled:
:PROPERTIES:
:ID: 5f9025e0-156c-4270-96ab-49011df83632
:END:

***** helpful
:PROPERTIES:
:ID: 81552b9b-46aa-46c8-8541-500059dda695
:END:

#+begin_src emacs-lisp
(after! (evil helpful)
  (evil-set-initial-state 'helpful-mode 'normal))
#+end_src

***** magit
:PROPERTIES:
:ID: a27830b2-b60a-4aca-b65a-4042392d7105
:END:

#+begin_src emacs-lisp
(after! (evil magit)
  (add-hook 'git-commit-mode-hook #'evil-insert-state))
#+end_src

***** org
:PROPERTIES:
:ID: 62d87b9a-6219-4feb-b46c-a6e2e4155a90
:END:

****** insert state
:PROPERTIES:
:ID: b9cde044-5190-4789-97c4-a124c6701cd4
:END:

#+begin_src emacs-lisp
(after! (evil org)
  (add-hook 'org-insert-heading-hook #'evil-insert-state)
  (after! org-capture
    (add-hook 'org-capture-mode-hook #'evil-insert-state)))
#+end_src

***** Info                                                            :disabled:
:PROPERTIES:
:ID: c6c401dc-a7cf-460d-9188-1ee8bb2dad24
:END:

#+begin_src emacs-lisp
(general-def
  (:map Info-mode-map)
  (:m "h"   #'Info-backward-node)
  (:m "l"   #'Info-forward-node)
  (:m "H"   #'Info-history-back)
  (:m "L"   #'Info-history-forward)
  (:m "r"   #'Info-history)
  (:m "J"   #'evil-scroll-page-down)
  (:m "K"   #'evil-scroll-page-up)
  (:m "f"   #'ace-link-info)
  (:m "u"   #'Info-up)
  (:m "U"   #'Info-top-node)
  (:m "m"   #'Info-menu)
  (:m "s"   #'Info-search)
  (:m "RET" #'Info-follow-nearest-node)
  (:m "q"   #'quit-window))
#+end_src

***** eshell
:PROPERTIES:
:ID: 0a974596-2004-4ed2-9053-8bc6db1acd84
:END:

****** evil operators
:PROPERTIES:
:ID: 142162a1-0495-427e-bac6-f2e8e63dd184
:END:

******* evil-change
:PROPERTIES:
:ID: 1a47ff34-8f3b-4845-b3e9-0ae0937c5c84
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change (beg end type register yank-handler delete-func)
    "Like `evil-change' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-change (max beg (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler delete-func))))
#+end_src

******* evil-change-line
:PROPERTIES:
:ID: 296c4f58-261f-4f1b-a333-7807ebef331b
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change-line (beg end type register yank-handler)
    "Change to end of line."
    :motion evil-end-of-line
    (interactive "<R><x><y>")
    (eshell/evil-change beg end type register yank-handler #'evil-delete-line)))
#+end_src

******* evil-delete
:PROPERTIES:
:ID: 63b0c253-a59e-409a-b593-36ddd84d8777
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete (beg end type register yank-handler)
    "Like `evil-delete' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-delete (if beg (max beg (point-min)) (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler))))
#+end_src

******* evil-delete-line
:PROPERTIES:
:ID: 017b5fe8-a27e-4bab-a014-8bf53258b92a
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete-line (_beg end type register yank-handler)
    "Change to end of line."
    :motion nil
    :keep-visual t
    (interactive "<R><x>")
    (eshell/evil-delete (point) end type register yank-handler)))
#+end_src

****** update cursors after entering eshell
:PROPERTIES:
:ID: 5384f57c-9eba-4f00-953a-92814a253ce9
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-set-initial-state 'eshell-mode 'insert))
#+end_src

***** smartparens
:PROPERTIES:
:ID: 4977e770-2c5b-4819-8c6d-ed2c794737fe
:END:

#+begin_src emacs-lisp
;; smartparens breaks evil-mode's replace state
(after! (evil smartparens)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode))
#+end_src

***** debugger-mode
:PROPERTIES:
:ID: 614215d3-33b1-482e-bf0e-c9d66cdb1c24
:END:

#+begin_src emacs-lisp
(after! evil (evil-set-initial-state 'debugger-mode 'emacs))
#+end_src

***** autoyasnippet
:PROPERTIES:
:ID: 851aaa47-5220-43a2-9861-b36d4cb9b803
:END:

#+begin_src emacs-lisp
(use-package! auto-yasnippet
  :config (advice-add #'aya-expand :after #'evil-insert-state)
  :setq (aya-persist-snippets-dir . (concat VOID-LOCAL-DIR "auto-snippets/")))
#+end_src

***** yasnippet
:PROPERTIES:
:ID: d3b2a618-d008-427e-9947-44741bb0bbf9
:END:

#+begin_src emacs-lisp
(after! (evil lispy)
  (general-def
    (:map evil-lispy-state-map)
    ("l" #'lispy-right)
    ("h" #'lispy-left)
    ("f" #'lispy-flow)
    ("j" #'lispy-down)
    ("k" #'lispy-up)
    ("d" #'lispy-different)
    ("o" #'lispy-other-mode)
    ("p" #'lispy-eval-other-window)
    ("P" #'lispy-paste)
    ("y" #'lispy-occur)
    ("z" #'lh-knight/body)))
#+end_src

*** evil-surround
:PROPERTIES:
:ID: ef933441-4891-48d8-a4aa-016702e55b48
:END:

#+begin_src emacs-lisp
(use-package! evil-surround :hook prog-mode-hook text-mode-hook)
#+end_src

*** evil-matchit
:PROPERTIES:
:ID: 30ff273a-253b-4cdc-8e86-22e5705f44c1
:END:

#+begin_src emacs-lisp
(use-package! evil-matchit :hook prog-mode)
#+end_src

*** evil-exchange
:PROPERTIES:
:ID: d1c40ac0-d143-4e27-847b-d3d8e72a552a
:END:

Package [[https://github.com/Dewdrops/evil-exchange][evil-exchange]] lets me swap two regions of text.

#+begin_src emacs-lisp
(use-package! evil-exchange
  :commands evil-exchange
  :init
  (general-def 'normal
    :prefix "g"
    "X" (list :def #'evil-exchange-cancel :wk "cancel")
    "x" (list :def #'evil-exchange :wk "exchange")))
#+end_src

*** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package! evil-visualstar
  :commands
  evil-visualstar/begin-search-backward
  evil-visualstar/begin-search-forward
  :bind (:map evil-visual-state-map
         ("#" . evil-visualstar/begin-search-backward)
         ("*" . evil-visualstar/begin-search-forward)))
#+end_src

** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

#+begin_src emacs-lisp
(use-package! expand-region
  :commands
  er/expand-region
  er/contract-region
  er/mark-symbol
  er/mark-word
  :init
  (general-def 'visual
    "V" #'er/contract-region
    "v" #'er/expand-region)
  :config
  (defadvice! quit-expand-region (:before evil-escape)
    "Properly abort an expand-region region."
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src

** avy
:PROPERTIES:
:ID: 71d016e2-a118-4468-8a01-fe86863bc030
:END:

[[https://github.com/abo-abo/avy][Avy]]

*** bootstrap
:PROPERTIES:
:ID: eff03171-05b3-4a70-93ee-0a0f2b2c64f4
:END:

#+begin_src emacs-lisp
(use-package! avy
  :commands avy-jump
  :setq
  (avy-background . t)
  ;; Jump only on current window.
  (avy-all-windows . nil)
  ;; Use avy keys.
  (avy-keys-alist . nil)
  (avy-keys . (list
               ;; homerow keys in alternating order.
               ?a ?j ?s ?k ?d ?l ?f ?\;
               ;; middle homerow keys
               ?g ?h
               ;; keys above homerow in alternating order
               ?t ?y ?r ?u ?e ?i ?w ?o ?q ?p
               ;; keys below homerow
               ?b ?n ?v ?m ?c ?, ?x ?. ?z ?/))
  (avy-style . 'at))
#+end_src

*** avy-command-helper
:PROPERTIES:
:ID:       814e98f9-5823-4e8f-9f89-49cdecf3d809
:END:

#+begin_src emacs-lisp
(defun avy:jump-to-regexp (regexp)
  (avy-jump regexp
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))))
#+end_src

*** avy commands
:PROPERTIES:
:ID: 01ee387f-f153-497e-b9fb-d62d5df9ebe1
:END:

#+begin_src emacs-lisp
(defun void/evil-beginning-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx word-start nonl)))

(defun void/evil-beginning-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx symbol-start nonl)))

(defun void/evil-end-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx nonl word-end)))

(defun void/evil-end-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx nonl symbol-end)))
#+end_src

*** bindings
:PROPERTIES:
:ID: a8febb0e-768b-412d-9d86-1f1439eced0e
:END:

#+begin_src emacs-lisp
(general-def 'normal
  "f" #'avy-goto-char
  "w" #'void/evil-beginning-of-word
  "W" #'void/evil-beginning-of-WORD
  "e" #'void/evil-end-of-word
  "E" #'void/evil-end-of-WORD)
#+end_src

** undo                                                               :disabled:
:PROPERTIES:
:ID: 87fde0b2-5db6-4b5f-8945-d469449f1207
:END:

*** undo-fu
:PROPERTIES:
:ID: 2cb27d5e-e26c-4805-9ee7-f93222d75220
:END:

#+begin_src emacs-lisp
(use-package! undo-fu
  :after-hook void-after-switch-buffer-hook
  :before-call after-find-file
  :setq
  (undo-limit . 400000)
  (undo-strong-limit . 3000000)
  (undo-outer-limit . 3000000)
  :bind
  ([remap undo] . undo-fu-only-undo)
  ([remap redo] . undo-fu-only-redo)
  :config
  (global-undo-tree-mode -1))
#+end_src

* Utility
:PROPERTIES:
:ID: 15266577-fc6e-4ec7-8277-3a94b6f4f926
:END:

** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

*** bootstrap
:PROPERTIES:
:ID: 8ed5b69c-be1f-4181-bd01-88fc33b148d6
:END:

#+begin_src emacs-lisp
(use-feature! eshell
  :commands eshell
  :idle-require
  em-alias em-banner em-basic em-cmpl
  em-dirs em-glob em-hist em-ls em-prompt
  em-script em-term em-unix
  :popup ("\\*eshell"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (side . bottom)
          (slot . 2))
  :setq
  (eshell-directory-name . (concat VOID-DATA-DIR "eshell/"))
  (eshell-history-file-name . (concat eshell-directory-name "history"))
  (eshell-prefer-lisp-functions . nil)
  (eshell-scroll-to-bottom-on-input . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand . t)
  (eshell-kill-processes-on-exit . t)
  (eshell-hist-ignoredups . t)
  (eshell-input-filter . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive . t)
  (eshell-error-if-no-glob . t)
  (eshell-banner-message . '(format "%s %s\n\n"
                             (propertize (format " %s " (string-trim (buffer-name)))
                              'face 'mode-line-highlight)
                             (propertize (current-time-string)
                              'face 'font-lock-keyword-face)))
  :config
  (remove-hook 'eshell-output-filter-functions
               'eshell-postoutput-scroll-to-bottom))
#+end_src

*** visual commands
:PROPERTIES:
:ID: fedfa200-7d17-408d-ba42-da401cba6419
:END:

#+begin_src emacs-lisp
(after! em-term
  (--each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (add-to-list 'eshell-visual-commands it)))
#+end_src

*** improvements
:PROPERTIES:
:ID: b3da5d39-1591-4a19-ae96-45a117a13f24
:END:

Eshell uses pcomplete as its completion engine.

**** pcomplete
:PROPERTIES:
:ID: 63de7a7f-431c-4652-aa55-45973b5a4c2a
:END:

This replaces the default popup window at the bottom of eshell. By using the
=completion-in-region= backend, it triggers ivy/helm for completion.

#+begin_src emacs-lisp
(defun eshell/pcomplete ()
  "Use pcomplete with completion-in-region backend."
  (interactive)
  (require 'pcomplete)
  (ignore-errors (pcomplete-std-complete)))
#+end_src

**** go to prompt on insert
:PROPERTIES:
:ID: 76bd909c-901c-4bc6-8848-d84b121a06c3
:END:

#+begin_src emacs-lisp
(defun eshell:goto-prompt-on-insert-h ()
  "Move cursor to the prompt when switching to insert mode."
  (when (< (point) eshell-last-output-end)
    (goto-char
     (if (memq this-command '(evil-append evil-append-line))
         (point-max)
       eshell-last-output-end))))
#+end_src

*** eshell commands
:PROPERTIES:
:ID: 4a7074f6-7f53-4950-9c92-be39b23e1d70
:END:

**** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package! eshell-z
  :after eshell
  :commands eshell/z
  :setq (eshell:z-file . (expand-file-name "z" eshell-directory-name))
  :config
  (defalias 'eshell:z-file 'eshell-z-freq-dir-hash-table-file-name))
#+end_src

**** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package! eshell-up
  :after eshell
  :commands eshell-up eshell-up-peek
  :init
  (defalias 'eshell/up 'eshell-up)
  (defalias 'eshell/pk 'eshell-up-peek)
  (defalias 'eshell/peek 'eshell-up-peek))
#+end_src

**** eshell-clear
:PROPERTIES:
:ID: 6ae332e7-f2e8-4a78-9bb8-c9b4f271a6a2
:END:

The shell often gets cluttered with many commands. It's often useful to clear it
and indeed there are many suggestions on how to do so online. However, many of
them involve erasing the eshell buffer or making it's previous contents
inaccessable. I don't like getting rid of information that could be important.
All I really wanted is to just scroll up to the top of the window so that the
previous contents weren't visible. Note that it is important that this command
returns nil. Eshell shell ignores output returns nil. However, when it returns
non-nil it prints it to the eshell buffer, which results in a residue
line--that's not what we want.

https://emacs.stackexchange.com/questions/28819/eshell-goes-to-the-bottom-of-the-page-after-executing-a-command

#+begin_src emacs-lisp
(defadvice! scroll-to-top (:override eshell/clear)
  "Scroll eshell buffer to top.
The effect of this is to clear the contents of the eshell buffer."
  (progn (call-interactively #'evil-scroll-line-to-top) nil))
#+end_src

*** display
:PROPERTIES:
:ID: 66d647e3-b83b-4469-bb62-75546c2fee64
:END:

**** prompt
:PROPERTIES:
:ID: c21591c9-43a2-4c6b-aac8-b46b41f4dc63
:END:

I got a lot of inspiration from the [[http://www.modernemacs.com/post/custom-eshell/][modern emacs blog]]. I think the
author's code is in general a good example of how to use macros to abstract a
task and make it much simpler than it would be otherwise.

***** with-face
:PROPERTIES:
:ID: ae757b22-27e1-4243-8da0-35c3a8e6ff65
:END:

#+begin_src emacs-lisp
(defmacro with-face! (string &rest props)
  "Return STR propertized with PROPS."
  `(propertize ,string 'face '(,@props)))
#+end_src

***** helpers
:PROPERTIES:
:ID: c29bac50-32e4-4128-8446-6f4153d3a7a0
:END:

Eshell prompt function finds eshell section functions specified by
[[helpvar:eshell:enabled-sections][+eshell-enabled-sections]] and concatenates their results in order to
generate the body of the eshell prompt.

#+begin_src emacs-lisp
(defun eshell:acc (acc x)
  "Accumulator for evaluating and concatenating `eshell:enabled-sections'."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc eshell:sep it))
    acc))

(defun eshell:prompt-func ()
  "Generate the eshell prompt.
This function generates the eshell prompt by concatenating `eshell:header' with
valid `eshell:enabled-sections' and the `eshell-prompt-string'."
  (concat eshell:header
          (->> eshell:enabled-sections
               (mapcar (lambda (it) (void-symbol-intern 'eshell-prompt-- it)))
               (-filter #'fboundp)
               (-reduce-from #'eshell:acc ""))
          eshell-prompt-string))
#+end_src

***** eshell components
:PROPERTIES:
:ID: c22a9cdb-9b9f-4f06-9c09-f330d454ab1f
:END:

This heading contains the parts that make up the eshell prompt. They are the
header, the separator, the section delimiter and, the meat of the prompt, the
actual eshell sections.

#+begin_src emacs-lisp
(defvar eshell:sep "\s|\s"
  "Separator between eshell sections.")

(defvar eshell:section-delim "\s"
  "Separator between an eshell section icon and form.")

(defvar eshell:header "\s"
  "Eshell prompt header.")

(defvar eshell:enabled-sections '(dir git)
  "List of enabled eshell sections.
Each element of the list is an abbreviated.")

;; This is a regex that matches your eshell prompt so that eshell knows what to
;; keep readonly and what not to.
(setq eshell-prompt-regexp (rx (*? anything) "-> "))
(setq eshell-prompt-string " -> ")

(setq eshell-prompt-function #'eshell:prompt-func)
#+end_src

**** text wrapping
:PROPERTIES:
:ID: 7d155cf8-a90c-4183-a9be-5ffdc266d82a
:END:

#+begin_src emacs-lisp
(defhook! enable-text-wrapping (eshell-mode-hook)
  "Enable text wrapping."
  (visual-line-mode +1)
  (set-display-table-slot standard-display-table 0 ?\ ))
#+end_src

**** fringes
:PROPERTIES:
:ID: 312652e5-9975-4241-b709-7ed5b8537202
:END:

#+begin_src emacs-lisp
(defhook! remove-fringes (eshell-mode-hook)
  "Remove fringes for eshell."
  (set-window-fringes nil 0 0)
  (set-window-margins nil 1 nil))
#+end_src

**** hide modeline
:PROPERTIES:
:ID: 6dc13e60-abd4-40d0-be15-55b11c1faeb2
:END:

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook #'hide-mode-line-mode)
#+end_src

*** hooks
:PROPERTIES:
:ID: bfe31d56-9fae-4841-b078-d1f276f29611
:END:

**** aliases
:PROPERTIES:
:ID: 4f53fbac-9d9f-4e58-8e3a-0baad56d2ae9
:END:

***** setup
:PROPERTIES:
:ID: 1a346816-85a1-402e-81ac-c0dd0ef6dfc7
:END:

They are meant to emulate useful shell utilities, like fasd and bd.
Note that you may overwrite these in your [[helpvar:eshell-aliases-file][eshell-aliases-file]]. This is
here to provide an alternative, elisp-centric way to define your
aliases.

#+begin_src emacs-lisp
(defvar eshell:aliases
  '(("q"  "exit")
    ("ff"  "find-file $1")
    ("rg" "rg --color=always $*")
    ("ag" "ag --color=always $*")
    ("l"  "ls -lh")
    ("ll" "ls -lah"))
  "An alist of default eshell aliases. ")
#+end_src

***** initialize
:PROPERTIES:
:ID: 08af337e-61f3-4dce-bbf8-bab10c8d9793
:END:

#+begin_src emacs-lisp
(defvar eshell--default:aliases nil)

(defhook! enable-aliases (eshell-alias-load-hook)
  "Initialize eshell aliases."
  (setq eshell--default:aliases eshell-command-aliases-list
        eshell-command-aliases-list
        (append eshell-command-aliases-list
                eshell:aliases)))

(void-add-advice #'eshell-write-aliases-list :override #'ignore)
#+end_src

*** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:END:

#+begin_src emacs-lisp
(use-package! shrink-path
  :commands shrink-path-file)
#+end_src

** command-log-mode
:PROPERTIES:
:ID: 10226327-4c31-41db-b202-e4a9f44fc6fe
:END:

[[https://github.com/lewang/command-log-mode][command-log-mode]] keeps track of all the commands you run and displays them to
you on a side window.

#+begin_src emacs-lisp
(use-package! command-log-mode
  :commands command-log-mode global-command-log-mode
  :setq
  (command-log-mode-auto-show . t)
  (command-log-mode-open-log-turns-on-mode . nil)
  (command-log-mode-is-global . t))
#+end_src

** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

*** recentf
:PROPERTIES:
:ID: 527f55e1-48c3-4d90-a2ef-9dd463e6d1fd
:END:

#+begin_src emacs-lisp
(use-feature! recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  :commands recentf-open-files
  :config
  (void-add-advice #'recentf-save-list :before #'recentf-cleanup)
  (recentf-mode 1)
  :setq
  ;; (recentf-exclude . (list #'file-remote-p
  ;;                          "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
  ;;                          ;; ignore private Void temp files (but not all of them)
  ;;                          #'(lambda (file)
  ;;                              (-some-p (apply-partially #'file-in-directory-p file)
  ;;                               (list VOID-DATA-DIR)))))
  (recentf-max-menu-items . 0)
  (recentf-max-saved-items . 700)
  :custom
  (recentf-save-file (concat VOID-DATA-DIR "recentf"))
  (recentf-auto-cleanup 'never)
  (recentf-filename-handlers '(file-truename abbreviate-file-name)))
#+end_src

*** silence recentf
:PROPERTIES:
:ID: 15a971c4-b43a-4539-846e-70fe4e90d84a
:END:

#+begin_src emacs-lisp
(defadvice! silence-ouput (:around recentf-mode)
  "Shut up recentf."
  (shut-up! (apply <orig-fn> <args>)))
#+end_src

** saveplace
:PROPERTIES:
:ID: 6da42724-3137-4d70-9aed-9a978357679f
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-feature! saveplace
  :after-call after-find-file
  :setq
  (save-place-file . (concat VOID-DATA-DIR "saveplace"))
  (save-place-limit . nil)
  :config
  (save-place-mode)
  (defadvice! recenter-on-load (:after-while save-place-find-file-hook)
    "Recenter on cursor when loading a saved place."
    (when buffer-file-name (ignore-errors (recenter)))))
#+end_src

** savehist
:PROPERTIES:
:ID: 23867595-32fd-4270-97bd-3101cc681f00
:END:

#+begin_src emacs-lisp
(use-feature! savehist
  :idle-require custom
  :hook emacs-startup
  :setq
  (savehist-save-minibuffer-history . t)
  (savehist-autosave-interval . nil)
  (savehist-additional-variables . '(kill-ring search-ring regexp-search-ring))
  (savehist-file . (concat VOID-DATA-DIR "savehist")))

(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (setq kill-ring
        (mapcar (lambda (it) (when (stringp it) (substring-no-properties it)))
                (-non-nil kill-ring))))
#+end_src

** bookmarks
:PROPERTIES:
:ID: e1a569f8-d27a-4e0c-924a-3b123c62b6a2
:END:

[[info:emacs#Bookmarks][Bookmarks]] persistently store file locations. I use [[https://github.com/emacsmirror/bookmark-plus][bookmark-plus]] an increadibly
featureful bookmark extension package. Usually =xah lee= has good basic overviews
of topics on his site, check out the [[http://ergoemacs.org/emacs/bookmark.html — Emacs: Bookmark][one on bookmarks]]. I had already known about
=bookmark-plus=, however I hadn't really done anything with it. It was after I
read this [[https://emacs.stackexchange.com/questions/51853/retracing-steps-with-emacs-when-programming-exploring — search - Retracing steps with emacs (When programming /exploring) - Emacs Stack Exchange][question]].

#+begin_src emacs-lisp
(use-feature! bookmark
  :pre-setq
  (bookmark-default-file . (concat VOID-DATA-DIR "bookmarks"))
  (bookmark-save-flag . t))
#+end_src

** elfeed
:PROPERTIES:
:ID:       e018eeba-2e0b-4d9e-b813-bb9c427098f5
:END:

*** elfeed
:PROPERTIES:
:ID: 7454a51a-cb50-47e4-b0ab-7ac493d9d09d
:END:

[[https://github.com/skeeto/elfeed][elfeed]] is a news feed reader. I can give it a set of rss-feeds to blogs I like
to read and then read the articles in emacs! Typically, you'd set the feeds via
[[helpvar:elfeed-feeds][elfeed-feeds]], but with [[https://github.com/remyhonig/elfeed-org][elfeed-org]] I can do it by specifying a set of org files
from which to read my feeds. The org file I use is [[file:.local/config/elfeed.org][elfeed.org]]. The [[helpvar:rmh-elfeed-org-tree-id][rmh-elfeed-org-tree-id]] is the
tags that =elfeed-org= will consider when checking for feeds. Note that it's
case-sensitive so consider this if your tags (like me) capitalized. The
[[helpvar:elfeed-search-filter][elfeed-search-filter]] specifies how far back to go when looking for newsfeed
posts. So if you have some infrequent blogs, you might have to go further back
in time to see older posts.

#+begin_src emacs-lisp
(use-package! elfeed
  :commands elfeed
  :setq
  (elfeed-search-filter         . "@1-year-old")
  (elfeed-db-directory          . (concat VOID-DATA-DIR "elfeed/db/"))
  (elfeed-enclosure-default-dir . (concat VOID-DATA-DIR "elfeed/enclosures/"))
  (elfeed-show-entry-switch     . #'pop-to-buffer)
  (elfeed-show-entry-delete     . #'elfeed-kill-buffer)
  (shr-max-image-proportion     . 0.8))
#+end_src

*** elfeed org
:PROPERTIES:
:ID: e385b9b0-4681-4faa-9bfe-c759080ff5d9
:END:

#+begin_src emacs-lisp
(use-package! elfeed-org
  :after elfeed
  :demand t
  :setq
  (rmh-elfeed-org-files      . (list (concat VOID-ORG-DIR "elfeed.org")))
  (rmh-elfeed-org-tree-id    . "ELFEED")
  (rmh-elfeed-org-ignore-tag . "IGNORE")
  :config
  (let ((default-directory org-directory))
    (elfeed-org)))
#+end_src

** pomodoro
:PROPERTIES:
:ID: d8056c5a-6b10-49d1-befc-842cea64419e
:END:

[[https://github.com/baudtack/pomodoro.el][pomodoro]] is meant to provide functions to follow the pomodoro style of working.
There is a slight lag in emacs when I play a sound with ~(play-sound-file sound)~.
I might consider doing this asynchronously.

#+begin_src emacs-lisp
(use-package! pomodoro
  :commands pomodoro-start
  :setq
  (pomodoro-play-sounds       . t)
  (pomodoro-work-start-sound  . (concat VOID-ALERT-SOUNDS "A-Tone-His_Self-1266414414.wav"))
  (pomodoro-break-start-sound . (concat VOID-ALERT-SOUNDS "A-Tone-His_Self-1266414414.wav"))
  (pomodoro-work-time         . 25)
  (pomodoro-break-time        . 5)
  (pomodoro-long-break-time   . 15))

(defadvice! dont-use-call-process (:override play-pomodoro-sound)
  "Play sound without using the call-process."
  (play-sound-file <sound>))
#+end_src

** file browsing
:PROPERTIES:
:ID: a8a9edfe-a4c0-4531-92d5-a59991f4af92
:END:

*** dired
:PROPERTIES:
:ID: 4021c260-0529-4a65-a3c4-4651cc33c6ae
:END:

**** dired
:PROPERTIES:
:ID: 55109eeb-8e59-4d15-926e-fbe42ed28056
:END:

#+begin_src emacs-lisp
(use-feature! dired
  :setq
  (dired-recursive-copies . 'always)
  (dired-recursive-deletes . 'top)
  (dired-hide-details-hide-symlink-targets . nil))
#+end_src

**** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

**** Create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

*** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

**** bindings
:PROPERTIES:
:ID: 6e779de2-86b8-4856-8569-33f6e69e3b17
:END:

***** important
:PROPERTIES:
:ID: d1835a7a-2a51-4bc5-98f6-4e13d2b98ee4
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "m" #'dired-mark
  "d" #'dired-do-delete
  "s" #'dired-do-symlink
  "e" #'eshell
  "c" #'dired-do-copy
  "M" #'dired-mark-files-containing-regexp
  "r" #'dired-do-rename
  "U" #'dired-unmark-all-marks
  "x" #'dired-do-shell-command
  "a" #'avy-goto-line
  "C-r" #'ranger-refresh
  "f" #'find-file
  "q" #'ranger-close)
#+end_src


***** generic
:PROPERTIES:
:ID: 0b160960-0eab-4faa-911d-0d8aef12cc47
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

***** other
:PROPERTIES:
:ID: 45dab1c7-6558-42bc-a33e-91e1015d94ab
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "["                   #'dired-prev-dirline
  "]"                   #'dired-next-dirline
  "<"                   #'dired-prev-dirline
  ">"                   #'dired-next-dirline
  "^"                   #'dired-up-directory
  "k"                   #'dired-previous-line
  "j"                   #'dired-next-line
  "h"                   #'dired-up-directory
  "l"                   #'dired-find-file
  "RET"                 #'dired-find-file
  [remap next-line]     #'dired-next-line
  [remap previous-line] #'dired-previous-line)
#+end_src

***** other
:PROPERTIES:
:ID: 1caa851b-211b-4bee-8d2b-0df643410640
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "%"
  "u" #'dired-upcase
  "l" #'dired-downcase
  "d" #'dired-flag-files-regexp
  "r" #'dired-do-rename-regexp
  "C" #'dired-do-copy-regexp
  "H" #'dired-do-hardlink-regexp
  "R" #'dired-do-rename-regexp
  "S" #'dired-do-symlink-regexp
  "&" #'dired-flag-garbage-files)
#+end_src

***** marking
:PROPERTIES:
:ID: a4fff7fe-a895-4cf9-9737-685aa1b68e2f
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "*"
  "*"         #'dired-mark-executables
  "/"         #'dired-mark-directories
  "@"         #'dired-mark-symlinks
  "%"         #'dired-mark-files-regexp
  "("         #'dired-mark-sexp
  "."         #'dired-mark-extension
  "O"         #'dired-mark-omitted
  "c"         #'dired-change-marks
  "s"         #'dired-mark-subdir-files
  "m"         #'dired-mark
  "u"         #'dired-unmark
  "?"         #'dired-unmark-all-files
  "!"         #'dired-unmark-all-marks
  " <delete>" #'dired-unmark-backward
  " C-n"      #'dired-next-marked-file
  " C-p"      #'dired-prev-marked-file
  "t"         #'dired-toggle-marks)
#+end_src

***** other
:PROPERTIES:
:ID: 64d0879a-6b01-4898-976f-e3363b0a2d2c
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  [remap read-only-mode]   #'dired-toggle-read-only
  [remap toggle-read-only] #'dired-toggle-read-only
  "<delete>"               #'dired-unmark-backward
  [remap undo]             #'dired-undo
  [remap advertised-undo]  #'dired-undo)
#+end_src

***** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  ";" #'execute-extended-command)
#+end_src

**** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(use-package! ranger
  :commands deer ranger
  :setq
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly . t)
  (ranger-cleanup-on-disable . t)
  (ranger-omit-regexp . "^\.DS_Store$")
  (ranger-excluded-extensions . '("mkv" "iso" "mp4"))
  (ranger-deer-show-details . nil)
  (ranger-max-preview-size . 10)
  (ranger-modify-header . t)
  (ranger-hide-cursor . t)
  (ranger-dont-show-binary . t))

(setq image-dired-dir (concat VOID-DATA-DIR "image-dir"))
(setq dired-omit-verbose nil)
#+end_src

**** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! toggle-between-two-only (:override ranger-toggle-dotfiles)
  "Show/hide dot-files."
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

**** silence window check
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(defadvice! silence-output (:around ranger-window-check)
  "Silence `ranger-window-check'."
  (quiet! (apply <orig-fn> <args>)))
#+end_src


*** dired icons
:PROPERTIES:
:ID: 3b4561b3-18a5-475f-a8e8-e9cb7e213881
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons-dired :hook ranger-mode-hook)
#+end_src

** restart emacs
:PROPERTIES:
:ID: 2855f9fe-baac-43c4-9e7d-08c6fd118252
:END:

As it's name suggests [[https://github.com/iqbalansari/restart-emacs][restart-emacs]] provides a function (called ~restart-emacs~)
that restarts emacs. I haven't tested this in EXWM mode.

#+begin_src emacs-lisp
(use-package! restart-emacs :commands restart-emacs)
#+end_src

** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

*** auto-commit
:PROPERTIES:
:ID:       36b71eb7-b71d-47a0-ad0a-5d62825fffa3
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

#+begin_src emacs-lisp
(use-package! git-auto-commit-mode
  :ensure-system-package git
  :commands git-auto-commit-mode
  :setq
  (gac-automatically-push-p . nil)
  (gac-ask-for-summary . nil)
  (gac-default-message . #'gac:commit-message)
  (gac-commit-additional-flag . "-S"))
#+end_src

**** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac:commit-message (file)
  "Return the commit message for changes to FILE."
  (or (with-current-buffer (get-file-buffer file)
        (when (eq major-mode 'org-mode)
          (--> (org-ml-parse-subtree-at (point))
               (org-element-map it org-element-all-elements #'identity)
               (car it)
               (org-element-property :raw-value it)
               (format "Change at \"%s\".\n" it))))
      (format "Update %s" (f-base file))))
#+end_src

*** magit
:PROPERTIES:
:ID:       d6088ed3-417a-44e8-822b-ce4743f497d0
:END:

**** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:END:

#+begin_src emacs-lisp
(use-package! transient
  :setq
  (transient-default-level . 5)
  (transient-levels-file   . (concat VOID-DATA-DIR "transient/levels"))
  (transient-values-file   . (concat VOID-DATA-DIR "transient/values"))
  (transient-history-file  . (concat VOID-DATA-DIR "transient/history")))
#+end_src

**** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:END:

#+begin_src emacs-lisp
(use-package! magit
  :ensure-system-package git
  :commands magit-status magit-get-current-branch
  :idle-require f s with-editor git-commit package eieio lv transient
  :popup ("magit:"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :bind (:map magit-status-mode-map
         ([remap magit-mode-bury-buffer] . magit/quit))
  :setq
  (magit-completing-read-function . #'ivy-completing-read)
  (magit-revision-show-gravatars . '("^Author:     " . "^Commit:     "))
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . nil)
  :config
  (add-hook 'magit-popup-mode-hook #'hide-mode-line-mode))
#+end_src

**** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

**** evil-magit
:PROPERTIES:
:ID: 02025227-8f1a-45aa-b40a-aabf43a3041c
:END:

#+begin_src emacs-lisp
(use-package! evil-magit
  :before-call magit-status
  :config
  (shut-up! (evil-magit-init))
  (setq evil-magit-state 'normal)
  (require 'evil-magit nil :no-error))
#+end_src

*** git-gutter
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:END:

#+begin_src emacs-lisp
(use-package! git-gutter
  :ensure-system-package git
  :commands git-gutter-mode)
#+end_src

** server                                                             :built-in:
:PROPERTIES:
:ID: b2bc973f-7d24-431c-90bc-4c1055a9fc0a
:END:

#+begin_src emacs-lisp
(when (display-graphic-p)
  (after! server
    (when-let* ((name (getenv "EMACS_SERVER_NAME")))
      (setq server-name name))
    (unless (server-running-p)
      (server-start))))
#+end_src

** TODO autorevert                                                    :disabled:
:PROPERTIES:
:ID: 1d7c8bac-e523-4251-bb3c-b85f592fbfc3
:END:

#+begin_src emacs-lisp
(use-feature! autorevert
  :after-call switch-to-buffer find-file
  :setq
  (auto-revert-verbose . t)
  (auto-revert-use-notify . nil)
  (auto-revert-stop-on-user-input . nil)
  (revert-without-query . (list "."))
  :config
  (defun auto-revert-buffer-maybe ()
    (unless (or (bound-and-true-p auto-revert-mode)
                (active-minibuffer-window))
      (auto-revert-handler)))

  (defhook! auto-revert-buffer-maybe (void-after-switch-buffer-hook)
    "Auto revert current buffer, if necessary."
    (auto-revert-buffer-maybe))

  (defhook! auto-revert-auto-revert-visible-buffers (focus-in-hook after-save-hook)
    "Auto revert stale buffers in visible windows, if necessary."
    (--each (-uniq (mapcar #'window-buffer (window-list)))
      (with-current-buffer it
        (auto-revert-buffer-maybe)))))
#+end_src

** security
:PROPERTIES:
:ID: 313aedc2-c737-42b4-afaa-069ec33803aa
:END:

*** pass
:PROPERTIES:
:ID: 78e2ac6e-e465-482c-80bf-19ddfdaff31d
:END:

**** pass
:PROPERTIES:
:ID: 4ab61136-e27a-4bd1-bfd6-d99015819a1b
:END:

#+begin_src emacs-lisp
(use-package! pass
  :ensure-system-package pass
  :commands pass
  :setq
  (pass-username-field . "username"))
#+end_src

**** get password
:PROPERTIES:
:ID: 52d9423c-32fb-4538-9e69-537e458b52d5
:END:

#+begin_src emacs-lisp
(defun pass/get-password ()
  "Copy password from entry into kill ring."
  (interactive)
  (require 'pass)
  (password-store-copy
   (completing-read "Copy password of entry: "
                    (password-store-list (password-store-dir))
                    nil
                    t)))
#+end_src

**** auth source pass
:PROPERTIES:
:ID: 2cd2fcee-e503-4430-9f37-43fecb12ac19
:END:

#+begin_src emacs-lisp
(use-package! auth-source-pass
  ;; (:after-hook pre-command-hook)
  :setq
  (auth-source-pass-filename . "~/.password-store")
  (auth-source-pass-port-separator . ":")
  :config (auth-source-pass-enable))
#+end_src

**** epa
:PROPERTIES:
:ID: 9eeb5714-a5dc-4f88-8992-0bd3a158878b
:END:

#+begin_src emacs-lisp
(use-feature! epa
  :setq
  (epg-gpg-program . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

*** password-generator
:PROPERTIES:
:ID: 11bc4d9a-78df-4010-b81a-4a87b1443ea9
:END:

I'm sure that =pass= can generate custom passwords with some options or other, but
I do not like dealing with the command line. I want real elisp code please.

#+begin_src emacs-lisp
(use-package! password-generator
  :commands password-generator-simple password-generator-paranoid)
#+end_src

** uuidgen
:PROPERTIES:
:ID: 9becd3bb-e74e-4644-a716-5b941fbbda50
:END:

#+begin_src emacs-lisp
(use-package! uuidgen)
#+end_src

** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package! xr
  ;; :functions xr xr-pp
  )
#+end_src

** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

*** pdf-tools
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :ensure-system-package (libpng zlib poppler-glib)
  :magic ("%PDF" . pdf-view-mode)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :bind (:map pdf-view-mode-map
         ("j" . pdf-view-next-line-or-next-page)
         ("k" . pdf-view-previous-line-or-previous-page)))
#+end_src

*** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! build-pdf-into-program (:before pdf-view-mode)
  "Build the pdf-info program if it hasn't already been built."
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (--each (buffer-list)
        (with-current-buffer it
          (when (eq major-mode 'pdf-view-mode)
            (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

*** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(general-def 'normal pdf-view-mode-map
  "j" #'pdf-view-next-line-or-next-page
  "k" #'pdf-view-previous-line-or-previous-page
  "0" #'pdf-view-first-page
  "9" #'pdf-view-last-page
  "s" #'pdf-view-fit-width-to-window)
#+end_src

** circe
:PROPERTIES:
:ID: 65495471-b9b4-47cc-aa85-5a6ead4c6538
:END:

#+begin_src emacs-lisp
(use-package! circe)
#+end_src

** peristent scratch
:PROPERTIES:
:ID: 8180d63f-1c0c-4a03-8dbc-9a99bf0c9f0b
:END:

#+begin_src emacs-lisp
(use-package! persistent-scratch
  :commands persistent-scratch-restore
  :setq (persistent-scratch-save-file . (concat VOID-DATA-DIR "scratch")))
#+end_src

** alert
:PROPERTIES:
:ID: 07960fe7-7ef5-48db-bfd9-86c980a7599d
:END:

Notifications are very important. Messages from the =*Messages*= buffer are not
enough.

#+begin_src emacs-lisp
(use-package! alert
  :ensure-system-package libnotify
  :setq
  (alert-default-style . 'libnotify)
  (alert-log-messages . t))
#+end_src

** sudo-edit
:PROPERTIES:
:ID:       38a9aec6-f826-4ebc-82f1-08ace40c2287
:END:

Sometimes I'll want edit files with root privileges. This package let's you edit
a file from another user (=root= by default). To use it you just call [[helpfn:sudo-edit][sudo-edit]]
on the buffer you'd like to edit.

#+begin_src emacs-lisp
(use-package! sudo-edit :commands sudo-edit)
#+end_src

** yadm
:PROPERTIES:
:ID:       5783c785-cee0-4705-9b6b-eec5124f34a0
:END:

#+begin_src emacs-lisp
(defun void/dotfile-status ()
  (interactive)
  (require 'tramp)
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c"))))
  (magit-status "/yadm::"))
#+end_src

** plantuml
:PROPERTIES:
:ID:       4c452dea-a404-4443-9ecc-189c940d201e
:END:

#+begin_src emacs-lisp
(use-package! plantuml-mode
  :ensure-system-package plantuml
  :init
  (after! org
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
  :setq
  (plantuml-executable-path . (executable-find "plantuml"))
  (plantuml-jar-path . "/usr/share/java/plantuml/plantuml.jar")
  (plantuml-default-exec-mode . 'jar)
  (org-plantuml-jar-path . "/usr/share/java/plantuml/plantuml.jar")
  (org-plantuml-executable-path . (executable-find "plantuml")))
#+end_src

** super save
:PROPERTIES:
:ID:       bd455e73-4035-49b9-bbdf-3d59d4906c97
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during
idle time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see
[[helpvar:super-save-triggers][super-save-triggers]]). Note that this is the same strategy employed by
[[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages. Saving files like this reduces the likelihood of
user delays.

#+begin_src emacs-lisp
(use-package! super-save
  :hook emacs-startup
  :setq
  (super-save-idle-duration . 5)
  (super-save-auto-save-when-idle . t))
#+end_src

* Languages
:PROPERTIES:
:ID: 51e3b9b1-0e74-431e-a113-fe6f86a4b22a
:END:

** lisp
:PROPERTIES:
:ID: 9b7ec12e-e62b-447a-90dd-2fef0cc952ad
:END:

*** sly
:PROPERTIES:
:ID: 2e4ddfa7-2243-458c-8045-ef4a9f652d9c
:END:

[[https://github.com/joaotavora/sly][sly]] is an alternative to [[https://github.com/slime/slime][slime]].

#+begin_src emacs-lisp
(use-package! sly
  :ensure-system-package sbcl
  :setq (inferior-lisp-program . "/usr/bin/sbcl"))
#+end_src

*** clojure
:PROPERTIES:
:ID: 7941233e-6524-4da1-b6d9-05faf8991824
:END:

[[https://github.com/clojure-emacs/cider][cider]] is a repl for clojure.

#+begin_src emacs-lisp
(use-package! cider
  :ensure-system-package clojure
  :commands cider)
#+end_src

*** emacs lisp
:PROPERTIES:
:ID: f90ab909-dd53-41ca-bc77-849fb89ac6c8
:END:

**** printing
:PROPERTIES:
:ID: 954a5a72-1db9-4a40-b9cb-e9099bfd0f83
:END:

#+begin_src emacs-lisp
(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
#+end_src

**** electric-pair
:PROPERTIES:
:ID: 1febf5ab-f545-4a72-97ef-892740575a3a
:END:

#+begin_src emacs-lisp
#+end_src

**** fix elisp indentation
:PROPERTIES:
:ID: aa7f846f-8802-4c75-88d8-a438e2f63ccd
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! properly-calculate-indent (:override calculate-lisp-indent)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp <parse-start>) (integerp <parse-start>))
             (goto-char <parse-start>))
            ((null <parse-start>) (beginning-of-defun))
            (t (setq state <parse-start>)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

**** highlight-quoted
:PROPERTIES:
:ID: afacf700-86a9-4c1b-9062-7a28c11dcf69
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package! highlight-quoted
  :hook emacs-lisp-mode)
#+end_src

**** buttercup
:PROPERTIES:
:ID: 228fb805-620d-4519-822f-f633540f7b58
:END:

[[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]] is an emacs debugging suite.

#+begin_src emacs-lisp
(use-package! buttercup)
#+end_src

**** outorg
:PROPERTIES:
:ID: a3461ce0-8c5d-4bea-950e-b18ea6422672
:END:

Outorg adds overlays to make an org buffer look more readable. I do not want
these overlays.

#+begin_src emacs-lisp
(use-package! outorg
  ;; TODO: should be changed to `:functions'
  :commands outorg-convert-back-to-code outorg-convert-to-org)

(defadvice! dont-add-overlays (:around outorg-wrap-source-in-block)
  (cl-letf (((symbol-function #'overlay-put) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** outshine
:PROPERTIES:
:ID: ffeddf0d-aa29-473f-b73c-d94971d91da9
:END:

[[https://github.com/alphapapa/outshine][outshine]] is a clever package that tries to make elisp mode more like org mode.
It colors certain comments like org headings, and adds function for convertion
from elisp to org. My [[helpvar:VOID-INIT-FILE][void-init-file]] is written with =outshine= in mind.

#+begin_src emacs-lisp
(use-package! outshine
  :hook emacs-lisp-mode
  :config
  (general-def '(normal) emacs-lisp-mode-map
    "TAB" #'outline-toggle-children))
#+end_src

**** macrostep
:PROPERTIES:
:ID: 81e59dcc-7e23-4dd1-9917-06f0ab59f2a6
:END:

[[https://github.com/joddie/macrostep][macrostep]]

#+begin_src emacs-lisp
(use-package! macrostep
  :commands
  macrostep-expand
  macrostep-collapse
  macrostep-collapse-all
  :init (define-localleader-key!
          :infix "m"
          :keymaps 'emacs-lisp-mode-map
          "e" (list :def #'macrostep-expand :wk "expand")
          "c" (list :def #'macrostep-collapse :wk "collapse")
          "C" (list :def #'macrostep-collapse-all :wk "collapse all")))
#+end_src

*** hy
:PROPERTIES:
:ID: 6b62fbdd-448b-4b69-82f8-1e1231a10c3e
:END:

#+begin_src emacs-lisp
(use-package! hy-mode :mode "\\.hy\\'")
#+end_src

** markdown
:PROPERTIES:
:ID: 9d684855-961a-4294-8b90-44d2796526e2
:END:

I'm adding [[https://github.com/jrblevin/markdown-mode][markdown-mode]] so I can see =README= files.

#+begin_src emacs-lisp
(use-package! markdown-mode :mode "\\.md\\'")
#+end_src

** org
:PROPERTIES:
:ID: 7fd3bb4f-354c-4427-914c-9de2223f5646
:END:

Org mode introduces an elegant way of dealing with different languages in one
file. In an org file the background language is Org's own markup language that's
typically composed mostly of outline headlines. In the org markup language you
can embed multiple different languages in [[][source blocks]]. Additionally, org
mode provides a library of functions for dealing with these files. This includes
things like executing (or evaluating) source blocks, moving headlines to other
files, or even converting an org mode document into another format. As the name
=org= suggests, org is tool that's used for organization of data.

*** structures
:PROPERTIES:
:ID: 85ac0a35-4e44-41e6-a1f1-54698cb86212
:END:

**** todo-keywords
:PROPERTIES:
:ID: a32da379-654e-4b1a-83f4-cf9e4003d578
:END:

***** todo keywords
:PROPERTIES:
:ID: 2f0459d4-9afd-4fd9-bdba-c0a3dc993963
:END:

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "NEXT" "WAITING" "|" "DONE")
          (sequence "|" "DUPLICATE")
          (sequence "|" "CANCELLED"))))
#+end_src

***** return todo-keywords
:PROPERTIES:
:ID: 38385aee-1326-46d8-9eef-3bfa2e57c0cc
:END:

Knowing what the exact todo-keywords are is important so that I know exactly
when headline contents begin.

#+begin_src emacs-lisp
(defun org:todo-keywords ()
  "Return list of all TODO keywords."
  (--filter (and (stringp it) (not (string= "|" it)))
            (flatten-list org-todo-keywords)))
#+end_src

***** heading start
:PROPERTIES:
:ID: 0ebf90e8-cd14-4364-b26a-da6676b29089
:END:

#+begin_src emacs-lisp
(defun org:heading-start-regexp ()
  "Compute regexp for heading start."
  (rx-to-string `(: bol (1+ "*") space (opt (or ,@(org:todo-keywords)) space))))

(defun org:heading-goto-start ()
  "Go to first letter of headline."
  (let (case-fold-search)
    (beginning-of-line)
    (re-search-forward (org:heading-start-regexp)
                       (line-end-position))))
#+end_src

**** return
:PROPERTIES:
:ID: c161f1b0-dbc0-4240-8102-69e95f3fd62f
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond
   (and (org-at-heading-p)
        (looking-at-p (rx (* (or "\s" "\t"))
                          (opt (1+ ":" (1+ letter)) ":") eol)))
   (org/insert-heading-below)
   (t
    (call-interactively #'org-return))))
#+end_src

**** TODO scroll window to top
:PROPERTIES:
:ID: 149e9f0c-e984-42e6-afb1-03502eda41ea
:END:

I need this function for some org actions. Evil has this as
[[helpfn:evil-scroll-line-to-top][evil-scroll-line-to-top]] but I didn't want to depend on evil.

#+begin_src emacs-lisp
(defun org:scroll-window-to-top ()
  (let ((line (line-number-at-pos (point)))
        (col (current-column)))
    (goto-char (point-min))
    (forward-line (1- line))
    (move-to-column col)))
#+end_src

**** fix nearby line adjustment
:PROPERTIES:
:ID: 6168590a-db23-4f0b-bdd9-9d9666624af6
:END:

#+begin_src emacs-lisp
(defun org:prettify-nearby-headlines ()
  "Prettify display of nearby headlines."
  (save-excursion
    (while (org-up-heading-safe)
      (outline-show-children)))
  (outline-show-children)
  (let ((line (line-number-at-pos (point))))
    (goto-char (point-min))
    (forward-line (1- line)))
  (recenter (1- (max 1 scroll-margin)))
  (org-beginning-of-line))
#+end_src

**** unfold nearby headlines
:PROPERTIES:
:ID:       c8dddafd-d39c-4757-acd2-d1bdf2b0a3c9
:END:

=counsel-org-goto= is lets you fuzzy search a term among org headings. It is
invaluable when you have a large org file you're dealing with a large org file.
However, when jumping to a source block.

#+begin_src emacs-lisp
(defadvice! properly-unfold-surrounding-headlines (:around counsel-org-goto-action)
  "Properly unfold nearby headlines and reveal current headline."
  (prog1 (apply <orig-fn> <args>)
    (org:prettify-nearby-headlines)
    (when (org:heading-folded-p)
      (outline-toggle-children))))
#+end_src

**** helpers
:PROPERTIES:
:ID: 50b79866-2905-459e-9723-6b822dde9127
:END:

***** org-heading-folded-p
:PROPERTIES:
:ID: 919b2b6e-2c43-4fd5-87cc-cfc62cf75405
:END:

#+begin_src emacs-lisp
(defun org:heading-folded-p ()
  "Return t if an current heading is folded."
  (outline-invisible-p (line-end-position)))
#+end_src

***** headline-name
:PROPERTIES:
:ID: 97ac2e07-9db1-43e4-a71b-1a4ed959c7b1
:END:

#+begin_src emacs-lisp
(defun org:heading-name ()
  "Return the headline of the current heading."
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (unless org-complex-heading-regexp
      (let ((major-mode 'org-mode))
        (org-set-regexps-and-options)))
    (looking-at org-complex-heading-regexp)
    (match-string 4)))
#+end_src

***** beginning-of-headline
:PROPERTIES:
:ID: ac43317c-485e-4efb-aff7-36c3ab69ea79
:END:

#+begin_src emacs-lisp
(defun org:beginning-of-headline (&optional end)
  "Return the character position at the end of the headline."
  (let (case-fold-search)
    (save-excursion
      (org-back-to-heading)
      (looking-at org-complex-heading-regexp)
      (funcall (if end #'match-end #'match-beginning) 4))))
#+end_src

***** end-of-headline
:PROPERTIES:
:ID: b9f9115c-4f84-4894-b926-8c1b948c0246
:END:

#+begin_src emacs-lisp
(defun org:end-of-headline ()
  "Return the character position at the end of the headline."
  (interactive)
  (org:beginning-of-headline t))
#+end_src

***** heading
:PROPERTIES:
:ID: f6b74522-180a-485c-b946-f7fa2e18a826
:END:

#+begin_src emacs-lisp
(defun org:heading-end-of-heading ()
  "Return point at end of heading.")

(defun org:heading-block-lang ()
  "Return the language of the current language's source block."
  (save-excursion
    (org-back-to-heading)
    (re-search-forward org-babel-src-block-regexp)))
#+end_src

**** preserve point
:PROPERTIES:
:ID: 52781cc9-e1ca-4618-aa1b-6845494b5dc6
:END:

If possible org commands should preserve =point=. If this isn't possible (ie. when
deleting a subtree with), then should leave point at a place that is easy to
predict and convenient (as opposed to a random location).

***** start on beginning of first heading
:PROPERTIES:
:ID: 81732dde-85f7-4336-a9fd-351d8f74671f
:END:

It looks nice if when I'm on a heading when I first enter an org file.

#+begin_src emacs-lisp
(defhook! goto-first-heading (org-mode-hook)
  "Go to first heading when entering an org-mode file."
  (when (org-at-heading-p)
    (beginning-of-line)
    (org:heading-goto-start)))
#+end_src

***** fix bug with next visible heading
:PROPERTIES:
:ID: 9a3759e8-8928-47cb-97c9-9ce5ee673cba
:END:

[[helpfn:outline-next-visible-heading][outline-next-visible-heading]] continues to =EOB= after reaching the last visible
heading. It should just stop at the last visible heading. This advice checks to
see if it's gone farther than it should have and in that case goes back.

#+begin_src emacs-lisp
(defadvice! dont-end-at-eob (:around outline-next-visible-heading)
  "Fix bug where the next heading moves past last visible heading."
  (apply <orig-fn> <args>)
  (when (eobp) (apply #'outline-previous-visible-heading <args>)))
#+end_src

***** go to proper point after refile
:PROPERTIES:
:ID: 591045df-8d3e-4ff7-b4bc-c949222a0717
:END:

#+begin_src emacs-lisp
(defadvice! end-at-headline-start (:after org-refile org-cut-subtree org-copy-subtree)
  "After running body end at headline start."
  (when (org-at-heading-p) (org:heading-goto-start)))
#+end_src

**** commands
:PROPERTIES:
:ID: 86f0b9be-0033-46bd-8d02-7e506fe73ead
:END:

***** dwim
:PROPERTIES:
:ID: 93a6e45c-b23b-4639-9e1c-9f1aef0fb95a
:END:

****** insert
:PROPERTIES:
:ID: 1b8ccbb8-2614-4d2e-ab7c-e8bd23c2c02d
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

****** eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

****** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

****** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

****** up-heading
:PROPERTIES:
:ID: 1f25d3b0-7280-4012-94b5-b0fea2f686b3
:END:

#+begin_src emacs-lisp
(defun org/dwim-up-heading ()
  ""
  (interactive)
  (condition-case nil
      (progn (outline-up-heading 1)
             (outline-hide-subtree)
             (outline-show-children)
             (org:heading-goto-start))
    (error
     (unless (outline-invisible-p (line-end-position))
       (outline-hide-subtree))
     (org:heading-goto-start))))
#+end_src

***** jump to heading                                                      :avy:
:PROPERTIES:
:ID: 3c396b33-437c-410f-aff6-2106ade42621
:END:

#+begin_src emacs-lisp
(defun org/avy-jump-to-heading ()
  "Jump to the beginning of a visible heading using `avy'."
  (interactive)
  (org-back-to-heading)
  (avy-jump (rx bol (1+ "*") space (group nonl))
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))
            :action (lambda (point) (goto-char point)
                      (org:heading-goto-start))
            :group 1))
#+end_src

***** dwim jump to heading
:PROPERTIES:
:ID: 7ad9d757-57ba-4537-821f-8beae57f39eb
:END:

#+begin_src emacs-lisp
(defun org/dwim-jump-to-heading ()
  ""
  (interactive)
  (let ((origin (point)))
    (if (and (org/avy-jump-to-heading)
             (org:heading-folded-p))
        (progn (outline-toggle-children)
               (org:scroll-window-to-top))
      (goto-char origin))))
#+end_src

***** inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

****** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

****** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

****** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

****** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

*** source blocks
:PROPERTIES:
:ID: 2bb1b8ef-f41c-4dfa-8e47-549326f7ce05
:END:

Many of these =org-src= variables are not very applicable to me anymore because I
use =edit-indirect= to edit source blocks.
:PROPERTIES:
:ID: 3329768f-2669-43be-ad85-da2239082cc2
:END:

#+begin_src emacs-lisp
(use-feature! org-src
  :setq
  (org-edit-src-persistent-message . nil)
  (org-src-window-setup . 'current-window)
  (org-src-fontify-natively . t)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-src-preserve-indentation . t)
  (org-src-tab-acts-natively . t)
  (org-confirm-babel-evaluate . nil)
  (org-babel-default-header-args . '((:session . "none")
                                     (:results . "silent")
                                     (:exports . "code")
                                     (:cache . "no")
                                     (:initeb . "no")
                                     (:hlines . "no")
                                     (:tangle . "yes"))))
#+end_src

*** org-mode
:PROPERTIES:
:ID: c1c5724e-028a-42a5-a982-28d57203b335
:END:

#+begin_src emacs-lisp
(use-package! org
  :idle-require
  calendar find-func format-spec org-macs org-compat org-faces org-entities
  org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
  org-capture
  :setq
  (org-directory . VOID-ORG-DIR)
  (org-archive-location . (concat org-directory "archive.org::"))
  (org-default-notes-file . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text . t)
  (org-hide-emphasis-markers . t)
  (org-pretty-entities . t)
  (org-fontify-whole-heading-line . t)
  (org-fontify-done-headline . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation . nil)
  (org-cycle-separator-lines . 2)
  (outline-blank-line . t)
  (org-enforce-todo-dependencies . t)
  (org-use-fast-tag-selection . nil)
  (org-tags-column . -80)
  (org-tag-alist . nil)
  (org-log-done . 'time))
#+end_src

*** asthetic
:PROPERTIES:
:ID: 52f5560d-6e52-4234-88d8-d326bc97525a
:END:

To be honest, org mode has some pretty ugly syntax. The asterixes at the
beginning of a heading are ugly, org block end and begin lines are ugly,
property drawers are ugly. For a nice-looking, minimal, and non-distracting
appearance all this needs to be improved.

**** visibility
:PROPERTIES:
:ID: 71462363-ddd0-4734-a074-7b00fde06e82
:END:

***** hide lines
:PROPERTIES:
:ID: 533c108a-36d0-4686-9476-2588647402ed
:END:
=hide-lines= is a package which, as its name suggests, hides certain lines.
Specifically, it hides lines that match a regular expression you provide. You
can reveal them with [[helpfn:hide-lines-show-all][hide-lines-show-all]].

****** hide lines
:PROPERTIES:
:ID: a2ea1e7e-5049-4b5e-bb06-4f31cf89ae32
:END:

Particularly in boilerplate heavy languages like Org, hiding certain lines can
make reading documents much easier by reducing visual distraction. This package
though is in need of an update. It didn't work out of the box (see [[id:b358f324-9b64-4e83-8168-231ff1ab115d][hide-lines]]
and [[id:a3e62e0a-452b-429c-9558-139e7b83cf80][hl overlay fix]]).

#+begin_src emacs-lisp
(use-package! hide-lines
  :commands hide-lines hide-lines-matching)
#+end_src

****** =hl= overlay fix
:PROPERTIES:
:ID: a3e62e0a-452b-429c-9558-139e7b83cf80
:END:

The line ~(overlay-put overlay 'invisible 'hl)~ in [[helpfn:][hide-lines-add-overlay]] wouldn't
work with the argument =hl=. It works when you set it to =t= instead. Maybe =hl= is
depreciated.

#+begin_src emacs-lisp
(defadvice! fix-adding-overlay (:override hide-lines-add-overlay)
  "Add an overlay from `start' to `end' in the current buffer.
Push the overlay into `hide-lines-invisible-areas'."
  (let ((overlay (make-overlay <start> <end>)))
    (setq hide-lines-invisible-areas (cons overlay hide-lines-invisible-areas))
    (overlay-put overlay 'invisible t)))
#+end_src

****** make sure all lines are hidden
:PROPERTIES:
:ID: b358f324-9b64-4e83-8168-231ff1ab115d
:END:

When I tried hiding property drawers [[hfn:hide-lines-matching][hide-lines-matching]] left out the start and
end property lines. Only the property block body was hidden. This advice fixes
this.

#+begin_src emacs-lisp
(defadvice! fix-hide-matching-lines  (:override hide-lines-matching)
  "Hide lines matching the specified regexp."
  (interactive "MHide lines matching regexp: ")
  (set (make-local-variable 'line-move-ignore-invisible) t)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward <search-text> nil t)
      (hide-lines-add-overlay (match-beginning 0) (match-end 0)))))
#+end_src

***** toggle org properties
:PROPERTIES:
:ID: c2c54bd5-9148-45e9-a675-154bcbf13674
:END:

I want properties to exist--they are useful even if it's just to store an ID.
Yet, like most raw org syntax it looks ugly and takes up a lot of space.
Unless I explicitly ask for properties I don't want to see them.

#+begin_src emacs-lisp
(defun org/hide-property-drawers ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all '(drawers))
    (hide-lines-matching (concat (s-chop-suffix "$" org-property-re) "\n"))))
#+end_src

***** toggle end source lines
:PROPERTIES:
:ID: 18fdd2a0-df15-486f-97c6-594cba018a3e
:END:

#+begin_src emacs-lisp
(defun org/hide-source-block-delimiters ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all)
    (hide-lines-matching (rx "#+" (or "begin" "end") "_src" (* nonl) "\n"))))
#+end_src

***** ensure that everything is folded
:PROPERTIES:
:ID: 86437909-e4df-48ae-9e2f-bf364e92cc86
:END:

#+begin_src emacs-lisp
(setq-default org-startup-folded 'fold)

(defadvice! hide-all-property-drawers (:override org-set-startup-visibility)
  "Completely hide all text properties."
  ;; Hide property drawers on startup.
  (org/hide-property-drawers)
  (org-overview))
#+end_src

***** ensure headings are visible
:PROPERTIES:
:ID: c0395fe0-fa69-49c1-94ed-cdbb94031868
:END:

Sometimes the heading inserted doesn't remain visible.

#+begin_src emacs-lisp
(defhook! ensure-heading-are-visible (org-insert-heading-hook)
  "Ensure that heading remains visible after insertion."
  (-when-let (o (cdr (get-char-property-and-overlay (point) 'invisible)))
    (move-overlay o (overlay-start o) (line-end-position 0))))
#+end_src

***** display children in window
:PROPERTIES:
:ID: f7a9c5e7-fcf8-434a-a9b3-dbe4eadead78
:END:

#+begin_src emacs-lisp
(defun org:display-children-in-window ()
  "Scroll up window to maximize view of unfolded subtree.
If the subtree is unfolded and the end of the current subtree is outside of the
visible window, scroll up until the whole subtree is visible. If the whole
subtree can't fit on the visible window, only scroll up until the top of the
subtree is on the first line of the window (in other words, the beginning of
th subtree should always be visible)."
  (interactive)
  ;; Don't use `window-beg' and `window-end' because their values are
  ;; unreliable.
  (let ((subtree-beg
         (save-excursion (org-back-to-heading)
                         (line-beginning-position)))
        (subtree-end
         (save-excursion (org-end-of-subtree)
                         (line-end-position))))
    (save-excursion
      (while (and (pos-visible-in-window-p subtree-beg)
                  (not (pos-visible-in-window-p subtree-end)))
        (scroll-up 1))
      ;; Sometimes the line at the end is not fully visible. So I try to
      ;; scroll down an extra line.
      (unless (pos-visible-in-window-p subtree-beg)
        (scroll-down 1)))))
#+end_src

***** ensure children are visible
:PROPERTIES:
:ID: 479455ed-a0be-4ecc-af66-559abf53c77c
:END:

If I unfold a subtree and the end of the subtree is outside of the window and
there's space in the window above the subtree, scroll up as much as possible.

Note that I don't use [[helpfn:window-start][window-start]] and [[helpfn:window-end][window-end]] because [[info:elisp#Window Start and End][their values are
unreliable]]. They update when [[helpfn:redisplay][redisplay]] is called; and for efficiency, I don't
want to call this function through every iteration of the loop. Instead I used
[[helpfn:pos-visible-in-window-p][pos-visible-in-window-p]] to tell me if a point is still in the visible window. In
hindsight, using this function is even easier than using ~window-beg~ and
~window-end~ because it doesn't require any math on my part.

#+begin_src emacs-lisp
(defadvice! ensure-children-visible (:after outline-toggle-children)
  "Ensure children are visible after toggling."
  (unless (org:heading-folded-p)
    (org:display-children-in-window)))
#+end_src

**** fancy priorities
:PROPERTIES:
:ID: 306faaf1-fa4d-42bd-8863-ae73ca12cb61
:END:

[[package:org-fancy-priorities][org-fancy-priorities]] is a package that displays org priorities with an icon.

#+begin_src emacs-lisp
(use-package! org-fancy-priorities
  :hook org-mode
  ;; :setq
  ;; (org-fancy-priorities-list . (list (all-the-icons-material "priority_high")
  ;;                                    (all-the-icons-octicon "arrow-up")
  ;;                                    (all-the-icons-octicon "arrow-down")
  ;;                                    (all-the-icons-material "low_priority")))
  )
#+end_src

**** org superstar
:PROPERTIES:
:ID: c43700f5-ff24-46b2-aed5-a12f8d8bb347
:END:

[[package:org-superstar][org-superstar]] is a an =org-bullets= remake redesigned from the ground up.

#+begin_src emacs-lisp
(use-package! org-superstar
  :hook org-mode
  :pre-setq
  (org-superstar-headline-bullets-list . (list "◉" "○" "▷"))
  :setq
  (org-superstar-special-todo-items . t)
  (org-superstar-leading-bullet . ?\s))
#+end_src

*** links
:PROPERTIES:
:ID: dbc3d205-9831-41f0-95f8-1e8746e0be3a
:END:

To me links are one of the biggest drawing points to org-mode. The ability to
have documentation that can link to websites, files, info docs and even github
commits is too juicy to pass up. Why in the 21st century do we still have to
deal with such weak, plain text code documentation when we could use a more
powerful markup language?

**** ol
:PROPERTIES:
:ID: 21148ef5-0887-4560-9997-6059b3529a2d
:END:

#+begin_src emacs-lisp
(use-feature! ol
  :after org
  ;; :custom
  ;; (org-link-descriptive . t)
  ;; (org-link-use-indirect-buffer-for-internals . t)
  )
#+end_src

**** custom link types
:PROPERTIES:
:ID: 76f86439-8ee3-4688-b117-a51d18d365ce
:END:

***** helpvar
:PROPERTIES:
:ID: 20f9629a-f145-44df-b8b4-69c5394dc773
:END:

=helpvar= I a new link type that when pressed, opens a help buffer from [[https://github.com/Wilfred/helpful][helpful]] if
it's installed, otherwise it defaults to bringing up an regular emacs help buffer.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpvar-face (link)
    (if (boundp (intern link)) 'org-link 'error))

  (defun ol:helpvar-follow (link)
    (let ((var (intern link)))
      (if (require 'helpful nil :noerror)
          (helpful-variable var)
        (describe-variable var))))

  (org-link-set-parameters "helpvar" :face #'ol:helpvar:face :follow #'ol:helpvar:follow))
#+end_src

***** helpfn
:PROPERTIES:
:ID: 449a3953-dce5-41a1-afdf-129fa6fae573
:END:

=helpfn= is the same as helpvar except with functions.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpfn-face (link)
    (let ((fn (intern link)))
      (if (fboundp fn) 'org-link 'error)))

  (defun ol:helpfn-follow (link)
    (let ((fn (intern link)))
      (if (require 'helpful nil :no-error)
          (helpful-callable fn)
        (describe-function fn))))

  (org-link-set-parameters "helpfn" :face #'ol:helpfn-face :follow #'ol:helpfn-follow))
#+end_src

*** org capture
:PROPERTIES:
:ID: 81197df0-6744-4a63-a202-f7279d7b7119
:END:

Ever been in the middle of doing something when a thought in your head pops up
about some thing else? You can stop what you're doing but then you lose focus.
You can resolve to make note of it later but then you might forget. Capturing is
designed to confront this problem. While in the middle of a task you can quickly
jump into a small org buffer and write down an idea that you have, then close
it.

**** org capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(use-feature! org-capture
  :trigger org-ml ts
  :commands org-capture
  :popup ("\\`CAPTURE"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (slot . 10)))
#+end_src

**** doct
:PROPERTIES:
:ID: 287fb9c7-110e-4758-aab2-71f74079ade2
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[][doct docstring]]).
In org mode, capture templates are [[][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package! doct
  :after org-capture
  :demand t)
#+end_src

**** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

By default org capture templates have. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my question]]. I
need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

**** helpers
:PROPERTIES:
:ID:       e0eab71c-40e0-47bf-87b3-94bee126aff3
:END:

These functions are to help me reduce the boilerplate of defining a capture
template.

***** org-capture-file
:PROPERTIES:
:ID:       25fdde38-86d5-4ef4-aecb-81ceebec7c27
:END:

This function is a convenience wrapper to be used as the =:file= argument for [[helpfn:doct][doct
declarations]]. The reason I use this function instead of passing in the file path
is so that if VOID-CAPTURE-FILE is modified templates will still be added to the
right place.

#+begin_src emacs-lisp
(defun org-capture:file ()
  "Return `VOID-CAPTURE-FILE'.
This is a convenience wrapper for `doct' declarations."
  VOID-CAPTURE-FILE)
#+end_src

***** add to capture templates
:PROPERTIES:
:ID:       16c55272-f8c2-4798-9da1-2ab492769f44
:END:

[[helpfn:doct][doct]] returns the new value of capture templates. but it does not actually add
it. For convenience this function declare it and add it in all in one go.
Additionally, it removes any capture templates with the same key so that I can
freely re-evaluate it without cluttering my capture templates with duplicate
entries.

#+begin_src emacs-lisp
(defun org-capture:add-to-templates (declarations)
  "Set `org-capture-templates' to the result of (doct DECLARATIONS).
Before adding result, remove any members of `org-capture-templates' with the
same key as the one(s) being added."
  (cl-labels ((clean (templates)
                     (when templates
                       (cons (car templates)
                             (--remove (string= (caar templates) (car it))
                                       (clean (cdr templates)))))))
    (setq org-capture-templates
          (clean (-concat (doct declarations) org-capture-templates)))))
#+end_src

***** schedule and deadline times
:PROPERTIES:
:ID:       e5c8996f-0d93-4a76-9b30-baf40f70d74d
:END:

For capture templates that have deadlines, I set a start and an end date.

#+begin_src emacs-lisp
(defun org-capture::default-planning-node (&optional days-difference)
  "Return the default planning node for `org-capture-templates'."
  (let* ((days-difference (or days-difference 7))
         (now (ts-now))
         (later (ts-adjust 'day days-difference now))
         (beg (list (ts-year now) (ts-month now) (ts-day now)))
         (end (list (ts-year later) (ts-month later) (ts-day later)))
         (days-difference (or days-difference 7)))
    (org-ml-build-planning! :scheduled beg :deadline end)))
#+end_src

***** generic template
:PROPERTIES:
:ID:       7945bb08-cb78-4c7e-840d-3cf92b7e3677
:END:

To maximize code reusability, I create a generic template skeleton here. All of
my headlines should have their own UUID. And almost all of my headlines will
have the date created.

#+begin_src emacs-lisp
(defun org-capture::generic-template ()
  "Return the default `org-capture-template'."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-headline-set-node-property "CREATED" (ts-format))))
#+end_src

***** default template keywords
:PROPERTIES:
:ID:       b2fe70d3-cc88-40fb-a718-8dafaeb98694
:END:

#+begin_src emacs-lisp
(defvar org-capture:defaults
  (list :file #'org-capture:file
        :prepend t
        :empty-lines 1)
  "A plist of keywords that should always apply to capture templates.")
#+end_src

***** convenience macro for defining capture templates
:PROPERTIES:
:ID:       9a3ece9d-e8e4-4b32-b65b-4a992e9d20cf
:END:

#+begin_src emacs-lisp
(defmacro! define-capture-template! (name args &rest body)
  "Define a capture template."
  (declare (indent defun))
  (let* ((string-name (downcase (symbol-name name)))
         (body (or body '((org-capture::generic-template))))
         (defaults org-capture:defaults)
         (key (downcase (substring string-name 0 1))))
    `(after! org-capture
       (defun org-capture::<string-name>-template-node ()
         "Return capture template node for <string-name>."
         ,@body)
       (defun org-capture::<string-name>-template-string ()
         "Return capture template as a string."
         (->> (org-capture::<string-name>-template-node)
              (org-ml-to-trimmed-string)))
       (org-capture:add-to-templates
        (->> (list :keys ,key :template #'org-capture::<string-name>-template-string)
             (-concat ,args org-capture:defaults)
             (cons ,string-name))))))
#+end_src

***** default template keyword for evil
:PROPERTIES:
:ID:       2dd987b5-a4b7-4f51-8e71-5324e06d9e97
:END:

#+begin_src emacs-lisp
(after! (org-capture evil)
  (prepend! org-capture:defaults
    (list :hook #'evil-insert-state)))
#+end_src

**** capture templates
:PROPERTIES:
:ID: aeb0bc04-84a1-4f85-89f9-c2e04cefce92
:END:

I use [[https://github.com/ndwarshuis/org-ml][org-ml]] and [[https://github.com/progfolio/doct][doct]] to generate templates dynamically. By "dynamically"
I mean that a template for a given key is different every time I open it. This
is possible with regular capture templates via [[info:org#Template expansion][org template expansion]], but I think the
abstractions provided by =org-ml= and =doct= are even more robust and much easier to
extend.

***** website
:PROPERTIES:
:ID:       03d7ea80-5d55-4ecb-b0ba-c229090b1d5e
:END:

A small note to avoid invalid filenames or wanting to create a filename but
inadvertently adding a file to a directory I replace any forward slashes (=/=)
with =~=.

#+begin_src emacs-lisp
(define-capture-template! Website ()
  :immediate-finish t
  :after-finalize #'org-capture::save-webpage
  (let* ((url (exwm::browser-url))
         (pdf-name (s-match ))
         (pdf-path (format "%s%s.pdf" VOID-SCREENSHOT-DIR (s-replace "/" "~" pdf-name)))
         (link-to-pdf (org-ml-to-trimmed-string (org-ml-build-link pdf-path pdf-name))))
    (->> (org-capture::generic-template)
         (org-ml-headline-set-title! link-to-pdf nil)
         (org-ml-headline-set-node-property "SOURCE" url))))
#+end_src

***** question
:PROPERTIES:
:ID:       a672f3eb-43c1-4310-adcc-6d0022e50579
:END:

Sometimes I have questions that I want to record. It's kind of like a more
specific =TODO= because their "task" is always to be answered. I think it's
worth distinguishing them from tasks in which I need to perform an action that I
have no questions about. The purpose of this template is for problems and issues
I'm stumped on. This process can help me reason through as much as I can and
provide the perfect draft for a potential question for reddit or stackexchange.

#+begin_src emacs-lisp
(define-capture-template! Question ()
  (->> (org-capture::generic-template)
       (org-ml-set-property :tags '("question"))))
#+end_src

***** idea
:PROPERTIES:
:ID:       71864105-198a-4680-ad1d-bd3f40b7f0d6
:END:

#+begin_src emacs-lisp
(define-capture-template! Idea ()
  (->> (org-capture::generic-template)
       (org-ml-set-property :tags '("idea"))))
#+end_src

***** emacs
:PROPERTIES:
:ID: e6109a54-37af-44ba-852f-a1c34f910cb9
:END:

This capture template is for something emacs related I need to do.

#+begin_src emacs-lisp
(define-capture-template! Emacs ()
  (->> (org-capture::generic-template)
       (org-ml-set-property :todo-keyword "TODO")
       (org-ml-set-property :tags '("emacs"))
       (org-ml-headline-set-planning (org-capture::default-planning-node))))
#+end_src

***** generic todo
:PROPERTIES:
:ID:       3689e969-aefe-47f4-8d54-b23f08840374
:END:

#+begin_src emacs-lisp
(define-capture-template! todo ()
  (->> (org-capture::generic-template)
       (org-ml-set-property :todo-keyword "TODO")))
#+end_src

**** prevent capture templates from deleting windows
:PROPERTIES:
:ID:       a13e330a-33ff-4c1e-add4-00c5db4e6cd1
:END:

=org-capture= deletes all the other windows in the frame.

#+begin_src emacs-lisp
(defadvice! dont-delete-other-windows (:around org-capture-place-template)
  "Don't delete other windows when opening a capture template."
  (cl-letf (((symbol-function #'delete-other-windows) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

*** org agenda
:PROPERTIES:
:ID:       16c1da27-264f-47df-a9d4-3f3ad8fa460f
:END:

**** org agenda
:PROPERTIES:
:ID: 65b2885d-aca6-42b8-a8ad-e3ae077b9aae
:END:

[[helpfn:org-agenda-list][org-agenda-list]] is the function that actually takes you to the agenda for the
current week.

#+begin_src emacs-lisp
(use-feature! org-agenda
  :after org
  :commands (org-agenda org-agenda-list)
  :setq
  (org-agenda-files list VOID-CAPTURE-FILE)
  (org-agenda-start-on-weekday . 0)
  (org-agenda-timegrid-use-ampm)
  (org-agenda-skip-unavailable-files)
  (org-agenda-time-leading-zero . t)
  (org-agenda-text-search-extra-files quote
                                      (agenda-archives))
  (org-agenda-dim-blocked-tasks)
  (org-agenda-inhibit-startup . t))
#+end_src

**** org super agenda
:PROPERTIES:
:ID:       d4914094-9e4e-4269-a359-16c7abc6653a
:END:

#+begin_src emacs-lisp
(use-package! org-super-agenda)
#+end_src

*** org refile
:PROPERTIES:
:ID:       7cb6769d-2904-4675-b17d-f658edb5a917
:END:

**** org refile
:PROPERTIES:
:ID: 0174a708-8043-403e-b024-8ae29868564d
:END:

#+begin_src emacs-lisp
(use-feature! org-refile
  :pre-setq
  (org-refile-targets . `((,VOID-README-FILE . (:maxlevel . 10))
                          (,(concat VOID-ORG-DIR "code.org") . (:maxlevel . 10))))
  (org-refile-use-outline-path . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order . t)
  (org-outline-path-complete-in-steps . nil))
#+end_src

*** org id
:PROPERTIES:
:ID: e7ecff83-7ba6-4620-ac05-ebac2f250b7a
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-feature! org-id
  :commands org-id-get-create
  :setq
  (org-id-locations-file . (concat VOID-DATA-DIR "org-id-locations"))
  ;; Global ID state means we can have ID links anywhere. This is required for
  ;; `org-brain', however.
  (org-id-locations-file-relative . t)
  :hook (org-insert-heading . org-id-get-create))
#+end_src

*** org clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-feature! org-clock
  :commands org-clock-in
  ;; :before-call ((org-clock-in org-clock-out org-clock-in-last org-clock-goto org-clock-cancel) . (org-clock-load))
  :hook (kill-emacs . org-clock-save)
  :setq
  ;; org-clock-sound
  ;; org-show-notification-handler
  (org-clock-persist . 'history)
  (org-clock-persist-file . (concat VOID-DATA-DIR "org-clock-save.el"))
  ;; Resume when clocking into task with open clock
  (org-clock-in-resume . t)
  :config
  ;; set up hooks for persistence.
  (org-clock-persistence-insinuate))
#+end_src

*** org crypt
:PROPERTIES:
:ID:       f5278890-8b84-43df-b5dc-0ef8074bfba9
:END:

#+begin_src emacs-lisp
(use-feature! org-crypt
  :commands org-encrypt-entries org-encrypt-entry org-decrypt-entries org-decrypt-entry
  :hook (org-reveal-start . org-decrypt-entry)
  ;; :preface
  ;; ;; org-crypt falls back to CRYPTKEY property then `epa-file-encrypt-to', which
  ;; ;; is a better default than the empty string `org-crypt-key' defaults to.
  ;; (defvar org-crypt-key nil)
  ;; (after! org
  ;;   (add-to-list 'org-tags-exclude-from-inheritance "crypt")
  ;;   (add-hook! 'org-mode-hook
  ;;              (add-hook 'before-save-hook 'org-encrypt-entries nil t)))
  )
#+end_src

*** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package! org-journal
  :commands org-journal-new-entry
  :setq
  (org-journal-file-type . 'yearly)
  (org-journal-dir . (concat VOID-ORG-DIR "journal/"))
  (org-journal-find-file . 'find-file))
#+end_src

*** keybindings
:PROPERTIES:
:ID: ee444a86-1266-42dd-9fe8-40192db1fdde
:END:

**** narrowing and widening                                           :disabled:
:PROPERTIES:
:ID: 72bd1c81-bd60-472f-8166-20bb2a16093d
:END:

#+begin_src emacs-lisp
(general-def
  (:localleader "n")
  (:map org-mode-map)
  (:wk "Narrow" "" nil)
  (:wk "To Element" :n "e" #'org-narrow-to-element)
  (:wk "To Block"   :n "b" #'org-narrow-to-block)
  (:wk "To Subtree" :n "s" #'org-narrow-to-subtree)
  (:wk "Widen"      :n "w" #'widen))
#+end_src

**** replace evil folding commands to outline folding
:PROPERTIES:
:ID: b3a4908d-538e-4d4c-acc9-fbd822220f03
:END:

By default evil binds =za= to [[helpfn:evil-open-folds][evil-open-folds]] and =zb= to [[helpfn:evil-close-folds][evil-close-folds]]. They do
work in =org-mode= but I'd rather use the folding commands provided by =outline.el.=
The outline api actually seems pretty solid; better coded and simpler than the
org api it seems.

#+begin_src emacs-lisp
;; (general-def
;;   (:leader "z")
;;   (:n "a" #'outline-show-all)
;;   (:n "m" #'outline:hide-all-sublevels))

(general-def 'normal org-mode-map
  [tab] #'outline-toggle-children
  "TAB" #'outline-toggle-children)

(defun outline:hide-all-sublevels ()
  (interactive)
  (outline-hide-sublevels 1))

(general-def 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "l" #'org-do-demote
  "h" #'org-promote-subtree
  "L" #'org-demote-subtree
  "t" #'org-set-tags-command
  "r" #'org-capture
  "s" #'org-schedule
  "S" #'org-deadline
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

** lua
:PROPERTIES:
:ID: 9f458b76-489f-45e0-b99a-ad6a9a2ae182
:END:

#+begin_src emacs-lisp
(use-package! lua-mode :mode "\\.lua\\'")
#+end_src

** cpp
:PROPERTIES:
:ID:       2fecdcf5-f482-4672-8bc8-9e9e1e0e110b
:END:

*** modern font lock
:PROPERTIES:
:ID:       2778d03a-4ee0-4175-90e5-331140ca7faf
:END:

#+begin_src emacs-lisp
(use-package! modern-cpp-font-lock
  :hook (c++-mode . modern-c++-font-lock-mode))
#+end_src

*** demangle
:PROPERTIES:
:ID:       2cda9af3-c7e3-48b5-8b49-ec4c63d4f501
:END:

#+begin_src emacs-lisp
(use-package! demangle-mode
  :hook llvm-mode)
#+end_src

** TODO latex
:PROPERTIES:
:ID:       03b47c17-e217-4dd5-b48d-36ae54a8349e
:END:

*** tex
:PROPERTIES:
:ID:       da68dfd0-62c5-4101-a7f3-7b13df760670
:END:

#+begin_src emacs-lisp
(use-feature! tex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook (LaTex-mode . visual-line-mode)
  :setq
  (TeX-parse-self . t)
  (TeX-auto-save . t)
  ;; use hidden dirs for auctex files
  (TeX-auto-local . ".auctex-auto")
  (TeX-style-local . ".auctex-style")
  (TeX-source-correlate-mode . t)
  (TeX-source-correlate-method . 'synctex)
  ;; don't start the emacs server when correlating sources
  (TeX-source-correlate-start-server . nil)
  ;; automatically insert braces after sub/superscript in math mode
  (TeX-electric-sub-and-superscript . t))
#+end_src

*** auctex
:PROPERTIES:
:ID:       5d5d2e8f-3b95-4d1a-bcc0-1c4ec8f51202
:END:

#+begin_src emacs-lisp
(use-package! auctex)
#+end_src

*** adaptive wrap
:PROPERTIES:
:ID:       80c837fc-a8de-4c11-9c76-b54f58c9a157
:END:

#+begin_src emacs-lisp
(use-package! adaptive-wrap
  :hook (LaTeX-mode . adaptive-wrap-prefix-mode)
  :setq-default (adaptive-wrap-extra-indent . 0))
#+end_src

*** preview pane
:PROPERTIES:
:ID:       a1c99afc-ee73-42fd-b33d-7c61ad607e90
:END:

#+begin_src emacs-lisp
(use-package! latex-preview-pane)
#+end_src

* User Interface
:PROPERTIES:
:ID: ee57f711-9a4f-421f-b831-ab4907402e52
:END:

** help and documentation
:PROPERTIES:
:ID:       3c01c053-fe6f-4a7a-92a5-6d4de7caac0a
:END:

*** helpful
:PROPERTIES:
:ID: 25270809-b64e-4b9a-b0c2-95ffd047280c
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in
Emacs help facility which provides much more contextual information
in a better format.

#+begin_src emacs-lisp
(use-package! helpful
  :popup
  ("\\*Help.*"
   (display-buffer-at-bottom)
   (window-width . 0.50)
   (side . bottom)
   (slot . 4))
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command]  . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key]      . helpful-key))
#+end_src

*** elisp demos
:PROPERTIES:
:ID: d1164fd9-bfc6-4436-a249-136a63c76e40
:END:

This package improves help further by allowing you to add examples on how to use
a function or macro. It seems simple but having examples can really ease the
understanding of a verbally terse and dry command description.

#+begin_src emacs-lisp
(use-package! elisp-demos
  :commands elisp-demos-add-demo
  :advice (:after (helpful-update . elisp-demos-advice-helpful-update)))
#+end_src

* Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** which-key
:PROPERTIES:
:ID: 79d530ab-ab32-459e-853c-b1ec9eee37ef
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

#+begin_src emacs-lisp
(use-package! which-key
  :hook emacs-startup
  :setq
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns . nil)
  (which-key-add-column-padding . 1)
  (which-key-min-display-lines . 6)
  (which-key-side-window-slot . -10)
  (which-key-sort-order . #'which-key-prefix-then-key-order)
  (which-key-popup-type . 'minibuffer)
  :config
  (defhook! set-line-spacing (which-key-init-buffer-hook)
    (setq line-spacing 3))
  (which-key-add-key-based-replacements void-leader-key "<leader>")
  (which-key-add-key-based-replacements void-localleader-key "<localleader>"))
#+end_src

** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** dashboard
:PROPERTIES:
:ID: 9de45782-1683-40ef-aff2-95c0dbaa4ba7
:END:

#+begin_src emacs-lisp
(use-package! dashboard
  :demand t
  :hook (window-setup . dashboard-insert-startupify-lists)
  :init
  (defadvice! open-dashboard-instead (:override void-initial-buffer)
    (if void-debug-p (get-buffer "*Messages*")
      (get-buffer-create "*dashboard*")))
  :setq
  (dashboard-items . nil)
  (dashboard-startup-banner . 2)
  (dashboard-center-content . t)
  (initial-buffer-choice . #'void-initial-buffer))
#+end_src

*** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:void-init-time][void-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      ((featurep 'package) (length package-activated-list))
                      (t 0))
                (string-to-number (emacs-init-time)))))
#+end_src

*** banner path
:PROPERTIES:
:ID: 597af7c3-f5d2-4cf5-a93e-3dd3564fb34a
:END:

#+begin_src emacs-lisp
(defadvice! set-custom-banner-path (:override dashboard-get-banner-path)
  "Use the Void text banner."
  (concat VOID-LOCAL-DIR "void-banner.txt"))
#+end_src

*** navigator buttons                                                 :disabled:
:PROPERTIES:
:ID:       a4a9e0ae-ee44-4434-bcf6-b415ef348e45
:END:

**** navigator button
:PROPERTIES:
:ID:       63829df6-5ba9-477e-99e9-86aabf7f5862
:END:

This is a convenience macro that allows navigation buttons to be defined
declaratively and with a "defun-like" syntax.

#+begin_src emacs-lisp
(defmacro dashboard:define-naviator-button! (name args description &rest body)
  "Define a dashboard navigator button."
  (declare (indent defun))
  (let ((dashboard-fn dashboard:name-button)
        ((&plist ))
        ((&plist ) icon))
    `(alet (list ()
                 ,name
                 ,description
                 #',dashboard-fn)
       (push it dashboard-navigator-buttons))))
#+end_src

**** github link
:PROPERTIES:
:ID:       a3c05c71-bd42-4508-8738-5c75f95b29d6
:END:

#+begin_src emacs-lisp
(dashboard:define-naviator-button! Homepage ()
  "Browse Homepage."
  :icon "mark-github"
  (browse-url "https://github.com/Luis-Henriquez-Perez/dotfiles"))
#+end_src

**** go to readme
:PROPERTIES:
:ID:       1a666fec-9f7c-4153-9e9a-f0f4a74e4d31
:END:

#+begin_src emacs-lisp
(dashboard:define-naviator-button! README ()
  "Go to README."
  :icon "eye"
  :type faicon
  (browse-url "https://github.com/Luis-Henriquez-Perez/dotfiles"))
#+end_src

** hide-mode-line
:PROPERTIES:
:ID: 043e3474-7b66-4e73-9e0b-3347897dbdcc
:END:

[[https://github.com/hlissner/emacs-hide-mode-line][hide-mode-line]] is another package that does exactly what it's name says: hide
the mode line.

#+begin_src emacs-lisp
(use-package! hide-mode-line
  :hook Man-mode completion-list-mode)
#+end_src

** all-the-icons
:PROPERTIES:
:ID: 6a7c7438-42c0-4833-9398-fa9fd58515d1
:END:

A little bit of decoration and spice can go a long way. As its name suggests,
[[all-the-icons][all-the-icons]] is a package that contains a lot of icons ([[][here]] you can see
a few). In practice I use these icons to (1) make things look nicer and more
colorful and (2) enhance readability of plain text.

*** install all the icons if not installed                            :disabled:
:PROPERTIES:
:ID: 1cda0692-8f42-4bb3-b11d-da52e2004a55
:END:

This will install the icons if they're not already installed. Unless somehow the
fonts are deleted, this code should only take effect the first time installing
void. This helps achieve the goal to automate as much as possible on a fresh
VOID install. For writing this code I referenced the body of
[[helpfn:all-the-icons-install-fonts][all-the-icons-install-fonts]].

#+begin_src emacs-lisp
(defhook! install-icons-maybe (window-setup-hook)
  "Install icons if not installed."
  (let ((font-dir
         (cl-case window-system
           (x (concat (or (getenv "XDG_DATA_HOME")
                          (concat (getenv "HOME") "/.local/share"))
                      "/fonts/"))
           (mac (concat (getenv "HOME") "/Library/Fonts/" ))
           (ns (concat (getenv "HOME") "/Library/Fonts/" )))))
    (unless (--all-p (file-exists-p (concat font-dir it))
                     '("all-the-icons.ttf"
                       "file-icons.ttf"
                       "fontawesome.ttf"
                       "material-design-icons.ttf"
                       "octicons.ttf"
                       "weathericons.ttf"))
      (void-log "No icons installed. Installing...")
      (all-the-icons-install-fonts :ignore-prompt))))
#+end_src

*** boostrap
:PROPERTIES:
:ID: a13cf0ec-14e2-4d4b-b313-65fe68f0655b
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons
  :commands (all-the-icons-octicon
             all-the-icons-faicon
             all-the-icons-fileicon
             all-the-icons-wicon
             all-the-icons-material
             all-the-icons-alltheicon))
#+end_src

*** disable in tty
:PROPERTIES:
:ID: fce313d3-aa5a-4ea8-b994-1f9a8e33ab9d
:END:

In terminals these icons will not display correctly. I usually use emacs as a
graphical interface but.

#+begin_src emacs-lisp
(defadvice! disable-all-the-icons-in-tty (:around
                                          all-the-icons-octicon
                                          all-the-icons-material
                                          all-the-icons-faicon
                                          all-the-icons-fileicon
                                          all-the-icons-wicon
                                          all-the-icons-alltheicon)
  "Disable icons in tty."
  (if (display-graphic-p) (apply <orig-fn> <args>) ""))
#+end_src

** themes
:PROPERTIES:
:ID:       d21b01bd-b5fe-461e-bd3e-54bcde7a8244
:END:

*** humanoid themes
:PROPERTIES:
:ID:       8f35bc4a-9455-4736-8339-fe2c2d16c398
:END:

#+begin_src emacs-lisp
(use-package! humanoid-themes
  :pre-setq (humanoid-org-bold . nil))
#+end_src

*** solarized theme
:PROPERTIES:
:ID:       c651e4c0-e594-47e3-9ac9-b21933065d12
:END:

#+begin_src emacs-lisp
(use-package! solarized-theme
  :setq
  (solarized-distinct-doc-face . t)
  (solarized-use-variable-pitch . nil)
  (solarized-scale-org-headlines . nil)
  (solarized-emphasize-indicators . t)
  (solarized-scale-outline-headlines . nil))
#+end_src

*** spacemacs theme
:PROPERTIES:
:ID:       55e83d40-ea71-473b-b7fc-5d06a2f175af
:END:

#+begin_src emacs-lisp
(use-package! spacemacs-theme
  :pre-setq
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-comment-italic . t)
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-org-height . nil))
#+end_src

*** one theme
:PROPERTIES:
:ID:       bf58d6cd-4745-4a02-a9f9-f59a44206116
:END:

#+begin_src emacs-lisp
(use-package! one-themes
  :pre-setq
  (emacs-one-scale-org-headlines . nil)
  (emacs-one-use-variable-pitch . nil))
#+end_src

*** tao theme
:PROPERTIES:
:ID:       efecb8e6-3037-47d2-9e0b-3026936fedfa
:END:

#+begin_src emacs-lisp
(use-package! tao-theme)
#+end_src

*** avk themes
:PROPERTIES:
:ID:       81715ee2-2a28-4344-8d4d-e438df956d82
:END:

#+begin_src emacs-lisp
(use-package! avk-emacs-themes)
#+end_src

*** hemera theme
:PROPERTIES:
:ID: fb192344-8aef-4ab1-800d-6b5cd8c900b9
:END:

#+begin_src emacs-lisp
(use-package! hemera-theme)
#+end_src

*** circadian                                                         :disabled:
:PROPERTIES:
:ID:       1f8dfb73-9709-4b3b-b02f-0c81b04665f3
:END:

[[https://github.com/GuidoSchmidt/circadian.el][circadian]] manages the loading of themes at certain time.

#+begin_src emacs-lisp
(use-package! circadian)
#+end_src

*** gruvbox-theme
:PROPERTIES:
:ID:       5f159c08-4c4d-4837-9625-2232e70139f5
:END:

#+begin_src emacs-lisp
(use-package! gruvbox-theme)
#+end_src

* Keybindings
:PROPERTIES:
:ID: 226e2c5b-2b81-483a-9942-d0ca0fc80f1f
:END:

** general
:PROPERTIES:
:ID: 3260f794-2d7f-4a68-a36a-78af01e4a4a9
:END:

This heading is dedicated to general keybinding decisions I make.

*** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC" (list :def #'execute-extended-command :wk "M-x"))

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)

(general-def 'normal ";" #'execute-extended-command
  "q" #'delete-window)
#+end_src

*** scrolling pages
:PROPERTIES:
:ID: 4861fa41-7185-471f-bfad-bba1283414ce
:END:

I scroll pages all the time. The default binding for scrolling pages in evil are
=C-j= to scroll down and =C-k= to scroll up. These chords are too much for such
common commands however, so I bound them to =J= and =K= respectively.

#+begin_src emacs-lisp
(general-def 'normal
  "K" #'evil-scroll-page-up
  "J" #'evil-scroll-page-down)
#+end_src

*** increasing text scale
:PROPERTIES:
:ID: 927dedb6-eee9-47ff-9298-c2e21bbce524
:END:

As someone who spends much of his day on the computer.

#+begin_src emacs-lisp
(general-def '(emacs normal)
  "M--" #'text-scale-decrease
  "M-=" #'text-scale-increase)
#+end_src

** windows
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil                              :wk "window")
  "w" (list :def #'display-buffer :wk "display buffer")
  "o" (list :def #'other-window                      :wk "other window")
  "S" (list :def #'void/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'void/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'split-window-below                :wk "split below")
  "v" (list :def #'split-window-right                :wk "split right")
  "M" (list :def #'maximize-window                   :wk "maximize")
  "m" (list :def #'minimize-window                   :wk "minimize")
  "b" (list :def #'balance-windows                   :wk "move left")
  "d" (list :def #'delete-window                     :wk "delete current")
  "D" (list :def #'delete-other-windows              :wk "delete others")
  "h" (list :def #'windmove-left                     :wk "move left")
  "j" (list :def #'windmove-down                     :wk "move down")
  "k" (list :def #'windmove-up                       :wk "move up")
  "l" (list :def #'windmove-right                    :wk "move right")
  "x" (list :def #'ace-swap-window                   :wk "swap windows")
  "t" (list :def #'transpose-frame                   :wk "transpose")
  "n" (list :def #'eyebrowse-create-window-config    :wk "save window config")
  "J" (list :def #'eyebrowse-next-window-config      :wk "next window config")
  "K" (list :def #'eyebrowse-prev-window-config      :wk "prev window config"))
#+end_src

** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

In emacs, we change the buffer a window's displaying pretty often. That's why
efficient buffer navigation is a must. There are particular buffers which I
visit so often that it's worth having keybindings just for them.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                            :wk "buffer")
  "e" (list :def #'buffer-expose                :wk "expose")
  "p" (list :def #'previous-buffer              :wk "previous")
  "n" (list :def #'next-buffer                  :wk "next")
  "s" (list :def #'switch-to-buffer             :wk "switch")
  "b" (list :def #'switch-to-buffer             :wk "display")
  "d" (list :def #'display-buffer               :wk "display")
  "t" (list :def #'void/switch-to-todo-file     :wk "Void TODO")
  "S" (list :def #'void/open-scratch            :wk "*scratch*")
  "i" (list :def #'void/switch-to-init-org-file :wk "fallback")
  "I" (list :def #'void/switch-to-main-elisp    :wk "main.el")
  "m" (list :def #'void/switch-to-main-org-file :wk "Void README")
  "M" (list :def #'void/switch-to-messages      :wk "*messages*"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))
#+end_src

** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These keybindings are for opening particular apps. When I'm testing Void I like
to open another emacs instance.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "a"
  ""  (list :ignore t                       :wk "app")
  "a" (list :def #'counsel-linux-app :wk "open app")
  "E" (list :def #'elfeed                   :wk "elfeed")
  "d" (list :def #'deer                     :wk "deer")
  "r" (list :def #'ranger                   :wk "ranger")
  "e" (list :def #'void/open-emacs-instance :wk "emacs")
  "q" (list :def #'void/open-qutebrowser    :wk "qutebrowser")
  "q" (list :def #'void/open-next           :wk "next")
  "w" (list :def #'w3m                      :wk "w3m")
  "c" (list :def #'org-capture              :wk "capture"))
#+end_src

** file
:PROPERTIES:
:ID: 2231147b-88c9-4c63-9c75-488cd1465807
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "f"
  ""  (list :ignore t          :wk "file")
  "S" (list :def #'sudo-edit   :wk "sudo")
  "s" (list :def #'save-buffer :wk "save buffer")
  "f" (list :def #'find-file   :wk "find file")
  "r" (list :def #'ranger      :wk "ranger")
  "d" (list :def #'deer        :wk "deer"))
#+end_src

** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "e"
  ""  (list :ignore t                   :wk "eval")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "b" (list :def #'eval-buffer          :wk "buffer"))
#+end_src

** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "c"
  ""  (list :ignore t                                   :wk "code")
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "t"
  ""  (list :ignore t                    :wk "toggle/set")
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'counsel-fonts         :wk "set font")
  "f" (list :def #'void/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                      :wk "help")
  "h" (list :def #'describe-function       :wk "function")
  "v" (list :def #'describe-variable       :wk "variable")
  "c" (list :def #'describe-char           :wk "char")
  "k" (list :def #'describe-key            :wk "key")
  "f" (list :def #'describe-function       :wk "function")
  "l" (list :def #'global-command-log-mode :wk "command log")
  "a" (list :def #'apropos                 :wk "apropos"))
#+end_src

** quit
:PROPERTIES:
:ID: d4828ea9-5ee1-4424-8ff0-f700876d34fd
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                        :wk "quit")
  "q" (list :def #'evil-quit-all             :wk "normally")
  "s" (list :def #'void/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit        :wk "and save")
  "x" (list :def #'void/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'void/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'void/kill-emacs-brutally  :wk "brutally")
  "r" (list :def #'restart-emacs             :wk "and restart"))
#+end_src

** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t :wk "search")
  "s" (list :def #'swiper :wk "swiper"))

(define-leader-key!
  :infix "s"
  :keymaps 'org-mode-map
  "h" (list :def #'counsel-org-goto :wk "headlines"))
#+end_src

** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src
