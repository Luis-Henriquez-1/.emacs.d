* Version 0.1
:PROPERTIES:
:ID:       8fd5fdb0-d8e1-4f7e-a6db-4d033a05371d
:END:

** hooks now follow a naming convention
:PROPERTIES:
:ID:       dbe3f98a-0cec-4d12-b0f5-9745330a350d
:END:

All user defined hooks now have the format =hook-variable-name&action-to-be-done=.
If we wanted, for example, to restore the gc-cons-threshold after
=emacs-startup-hook=. The a hook would look like
=emacs-startup-hook&increase-garbage-collection=.

** add improvements to defhook!
:PROPERTIES:
:ID:       cc995576-2322-45cd-82ed-4b083f94d618
:END:

The purpose of this change is to extend and improve the functionality of
=defhook!= macro. Specifically, I introduce a consistent naming scheme for
user-designed hooks (incidentally with very concise syntax), a logging system
that facilitates , and a rich set of keywords that increase the expressiveness
of declaring hooks.

To add this functionality I scrapped the =defhook!= macro I wrote in favor of the
[[https://github.com/neil-smithline-elisp/defhook][defhook package]]. This package was created in 2012.

**** improve syntax
:PROPERTIES:
:ID:       78554953-f62b-43ea-aade-a57eacb99655
:END:

***** typical syntax
:PROPERTIES:
:ID:       0d0c2108-8c15-44bb-a7c1-7fba27037543
:END:

=defhook!= now takes in the the hook variable in it's argument list.
Additionlly, it can use keywords as specified in [[helpfn:defhook][defhook]] in
its argument list as well.

#+begin_src emacs-lisp
(defhook! do-something (some-hook :eval-after simple)
  "Hello world."
  (+ 1 1))
#+end_src

***** add the ability to specify keyword arguments below
:PROPERTIES:
:ID:       4a7e8e71-745a-4937-9611-86f72b9fa9b6
:END:

The syntax of hooks.

#+begin_src emacs-lisp
(defhook! boost-garbage-collection (emacs-startup-hook)
  "Increase the frequency of garbage collection."
  :eval-after simple
  :append t
  (setq gc-cons-threshold most-positive-fixnum))
#+end_src

***** add ability to have multiple hooks
:PROPERTIES:
:ID:       f0a7f0e5-b9b8-4a21-bf3e-90b903fce2c3
:END:

#+begin_src emacs-lisp
(defhook! say-lalala (emacs-startup-hook emacs-lisp-mode-hook)
  "Say \"lalala\"."
  (message "lalala"))
#+end_src

**** creates hook names that meets naming conventions
:PROPERTIES:
:ID:       a43264d4-f30a-4411-9443-4bdda08d4290
:END:

The name of the advice(s) defined by defhook is determined by the specified name.

**** debugging/documenting capabilities
:PROPERTIES:
:ID:       b4130374-2b99-475b-b369-831a53a9b2c6
:END:

** don't scale headlines in one-themes

:PROPERTIES:
:ID:       6a0c947c-660a-439f-aa14-4b103d8b7548
:END:

** replace selectrum with ivy/counsel
:PROPERTIES:
:ID:       3ec4e606-653b-4d0a-af59-71b7518426c0
:END:

The purpose of this change is to replace selecturm with ivy and counsel. In the
following paragraphs I explain my reasoning.

I think that selectrum is likely the future completion framework for emacs
because its code is more maintainable and less buggy than ivy's. This will start
to make a difference the more that users want to customize ivy in a way that the
creator did not anticipate.

Right now though, ivy has more features and it has a library of useful
convenience functions (counsel). Selectrum has no such library, so you'd have to
write your own version of =swiper=, =ivy-switch-buffer=, =counsel-org-goto=, etc
that are not dependant on =ivy-read= yourself. This is a lot of work when
counsel already has them working and tested.

Note that it is true Selectrum has a wiki with these functions and there are
plans of adding some to it's own version of counsel (selectrum-config), but
still counsel has a much greater number of useful functions, and therefore more
featureful and tested than the ones informally created for the selectrum wiki.

All in all, ivy/counsel is currently the more complete, featureful and supported
package and for this reason I move to use it as Void's main completion
framework.

** saving at certain triggers and during idleness
:PROPERTIES:
:ID:       05722dc4-91d7-47e1-8ad2-3233ba06a442
:END:

The purpose of this change is minimize the possibility of losing information
without compromising user experience. Auto-saving, if done at fixed intervals,
can cause lags and delays as the user is typing. I introduce the package
[[https://github.com/bbatsov/super-save][super-save]] to remedy this ussue (see [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][this headline]] for more details).

** updates to advising
:PROPERTIES:
:ID:       5abd6d61-919b-4f8c-a9e6-f9b6ea48b11a
:END:

This change has many purposes. One is to establish a concise and consistent standard for
naming a user-added advice. Another is to provide debugging capabilities via
[[id:][void:log]] I can use to find problems in my configuration.

*** [[id:8506fa78-c781-4ca8-bd58-169cce23a504][expire advice]]
:PROPERTIES:
:ID:       07a4f3ee-2593-4fda-b80b-71f33cbf52c6
:END:

This change introduces =expire advice=. These are advices that can remove their
advisees (or targets) from any advice they are in and unbind them.

*** defadvice!
:PROPERTIES:
:ID:       de153171-3126-41b2-855e-255bdf61d90b
:END:

**** anaphoric arguments
:PROPERTIES:
:ID:       55d471c5-26ef-4202-a151-506b0858b884
:END:

You can optionally omit advice arguments in =defadvice!=. If you need to reference
those arguments you can use anaphoric variables.

**** on redundant advice arguments
:PROPERTIES:
:ID:       93a02a02-b69f-44d0-b2e3-14f1f26f5f90
:END:

When defining an advice in Emacs the arguments of the advice function are often
redundant. This is especially the case with [[info:elisp#Advice Combinators][around advice]] whose arguments
are almost always =(orig-fn args)=. Often you need them to be the same as with the
original function. Making them different would lead to an error. To avoid user
(ie. me) mistakes. I base. Why should we need to specify the arguments of an
advice if we already pass in the function to be advised? For all advices expect
around advice, the arguments must be the same or more than the symbol being
advised.

*** define a consistent naming scheme
:PROPERTIES:
:ID:       70d49b15-1f0d-4c5c-a1b5-a333ed5adb31
:END:

Now advices have a consistent syntax. The functions [[id:4750f4dc-053b-4062-bd6c-aeeed6cdbcd9][void:add-advice]] and
[[id:baf2dd59-b37b-47bc-a1d2-815ba925d1bd][void:remove-advice]] as well as the macro [[id:1e0f3a27-a7d8-4e28-a359-f42ed7a16033][defadvice!]].

*** outputting messages on =void:debug=
:PROPERTIES:
:ID:       c8915acd-626e-429f-a8c3-1416f16bb00d
:END:

Advises output log messages when =void:debug= is non-nil.

** *Breaking Change* change naming convention from =void:= to =void-=.
:PROPERTIES:
:ID:       71944cc7-898f-4679-9492-701d8e69e0dc
:END:

Since there is currently no package named =void= and it is more consistent with
emacs naming conventions to use the "-", I've decided to just use the prefix
=void-= for naming variables.

** *Breaking Change* replace leaf with =def-package=
:PROPERTIES:
:ID:       83aa2d9a-5fdf-48bb-a182-cb7af487cf02
:END:

The purpose of this change is to make it very easy to customize leaf keywords.

*** reasons for the package
:PROPERTIES:
:ID:       b79fe237-ea49-46cc-b43a-f93f687035d3
:END:

**** cumbersome
:PROPERTIES:
:ID:       6593c1ad-84f0-410d-b110-dd550e533543
:END:

While *much* easier and straight-forward than =use-package=, leaf's mechanism for
defining keywords is still cumbersome.

This stems from the fact that leaf does not use functions to store
transformations into forms. Instead, it uses raw lisp forms. For one thing, this
makes reading the data structure via just evaluating the variable in a buffer or
via [[][]] really hard. This encourages the use of =eval= which should be avoided.
It forces code to be much more indirect to deal with the fact that these are
evaluated forms.

A clear problem we see is with =leaf-normalize=. It is a variable contains
condition case clauses that determine how the value of a particular key should
be normalized.
