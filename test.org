* defhook!
:PROPERTIES:
:ID:       130bc7cf-cfb9-43e0-91ba-2035d4b22012
:END:

** accepts multiple hooks
:PROPERTIES:
:ID:       ef5c4f7d-7a25-41cb-b75f-c1c73e8ec4db
:END:

#+begin_src emacs-lisp
(ert-deftest defhook-accepts-multiple-hooks ()
  (let (a-hook b-hook)
    (defhook! hello-world (a-hook b-hook)
      (+ 1 1))
    (should (equal a-hook '(a-hook&hello-world)))
    (should (equal b-hook '(b-hook&hello-world)))
    ;; cleanup
    (fmakunbound 'a-hook&hello-world)
    (fmakunbound 'b-hook&hello-world)))
#+end_src

* ivy tests
:PROPERTIES:
:ID:       35fb8af3-c160-4330-8195-b159d97700a0
:END:

** everything checks out
:PROPERTIES:
:ID:       d9402509-d00c-44d4-86aa-de6d8f006594
:END:

#+begin_src emacs-lisp
(ert-deftest ivy-filtering-working-as-expected ()
  ;; make sure `ivy-sort-max-size' is not too low.
  (should (>= 30000 ivy-sort-max-size))
  ;; prescient-save-file
  (should (string= prescient-save-file (concat VOID-DATA-DIR "prescient-save.el")))
  ;; orderless should be doing the filtering.
  (should (null ivy-prescient-enable-filtering))
  ;; ivy prescient can handle the sorting.
  (should ivy-prescient-enable-sorting)
  ;; these should be on.
  (should (and ivy-prescient-mode prescient-persist-mode))
  ;; orderless should be the default sorter.
  (should (eq (alist-get t ivy-re-builders-alist) #'orderless-ivy-re-builder)))
#+end_src

* defadvice
:PROPERTIES:
:ID:       f9dbab12-fa2d-4486-97b0-70b091d6527c
:END:

** advice-p
:PROPERTIES:
:ID:       2ca4de42-5280-45e3-97ee-ab423c3cb1ad
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-p ()
  (should-not (void-advice-p 'hello))
  (should (void-advice-p 'hello@world)))
#+end_src

** advice-name
:PROPERTIES:
:ID:       2bd281c2-bb9a-4d1b-a926-94854cd1cf9b
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-name ()
  (should (eq (void-advice-name 'hello 'world) 'hello@world))
  (should (void-advice-p (void:advice-name 'hello 'world))))
#+end_src

** advice-target
:PROPERTIES:
:ID:       e3a21c47-8293-49e1-876f-1dd0f054eec1
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-target ()
  (should (eq 'hello (void-advice-target 'hello@world))))
#+end_src

** add-advice
:PROPERTIES:
:ID:       ad260c52-0830-499a-8880-f5190ba89788
:END:

#+begin_src emacs-lisp
(ert-deftest void-add-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1)))
    ;; test function works.
    (should (= 1 (test-fn)))
    (void-add-advice #'test-fn :override #'ignore)
    ;; successfully advised test function.
    (should (null (test-fn)))
    ;; added `test-fn@ignore' as advice.
    (should (advice-member-p #'test-fn@ignore #'test-fn))))
#+end_src

** remove-advice
:PROPERTIES:
:ID:       80f507e8-053f-45a1-8609-ddf5972874f6
:END:

#+begin_src emacs-lisp
(ert-deftest void-remove-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1)))
    (void-add-advice #'test-fn :override #'ignore)
    (should (advice-member-p #'test-fn@ignore #'test-fn))
    (void-remove-advice #'test-fn #'ignore)
    (should-not (advice-member-p #'test-fn@ignore #'test-fn))))
#+end_src

** expiring advice
:PROPERTIES:
:ID:       7a05e9cd-55d3-4c0d-970b-f2eb60f8a645
:END:

#+begin_src emacs-lisp
(ert-deftest void-expire-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1))
            ((symbol-function #'test-fn@some-advice) (lambda (&rest _) 0)))
    (should (= 1 (test-fn)))
    (advice-add #'test-fn :override #'test-fn@some-advice)
    ;; `test-fn' was overriden successfully.
    (should (zerop (test-fn)))
    (advice-add #'test-fn@some-advice :around (void-expire-advice #'test-fn@some-advice))
    ;; The expire advice is present.
    (should (advice-member-p #'test-fn@some-advice@expire #'test-fn@some-advice))
    ;; It shouldn't expire immediately.
    (should (zerop (test-fn)))
    ;; ;; Now it should expire.
    (should-not (advice-member-p #'test-fn@some-advice #'test-fn))
    (should (= 1 (test-fn)))
    (should (= 1 (test-fn)))
    ;; The expiring advise should be unbound
    (should-not (boundp #'test-fn@some-advice@expire))
    ;; Works with functions that return t at different times.
    (let ((counter 0))
      (advice-add #'test-fn :override #'test-fn@some-advice)
      (->> (lambda () (= 2 (cl-incf counter)))
           (void-expire-advice #'test-fn@some-advice)
           (advice-add #'test-fn@some-advice :around ))
      (should (zerop (test-fn)))
      (should (zerop (test-fn)))
      (should-not (advice-member-p #'test-fn@some-advice #'test-fn))
      (should (= 1 (test-fn))))))
#+end_src

** does proper thing with around advice
:PROPERTIES:
:ID:       44b4aadc-a579-4b86-bdbc-df965e8d7c89
:END:

#+begin_src emacs-lisp
(ert-deftest around-advice-works ()
  (cl-letf (((symbol-function #'hello-world) (lambda (one two) (* one two))))
    (should (= (hello-world 1 2) 2))
    ;; shouldn't have any advices on it.
    (should-not (advice-mapc (lambda (it _) it) #'hello-world))
    ;; add an around advice.
    (defadvice! do-something-cool (:around hello-world)
      (1+ (apply <orig-fn> <args>)))
    ;; now should have an advice.
    (should (advice-member-p #'hello-world@do-something-cool #'hello-world))
    (should (= (hello-world 1 2) 3))
    ;; remove the advice.
    (advice-remove #'hello-world #'hello-world@do-something-cool)
    (should-not (advice-member-p #'hello-world@do-something-cool #'hello-world))
    ;; should return original value.
    (should (= (hello-world 1 2) 2)))
  (when (fboundp #'hello-world)
    (fmakunbound #'hello-world))
  (when (fboundp #'hello-world@do-something-cool)
    (fmakunbound #'hello-world@do-something-cool)))
#+end_src

** binding works
:PROPERTIES:
:ID:       dc43c155-ae49-463c-9641-60bd15431d97
:END:

#+begin_src emacs-lisp
(ert-deftest other-advices-work ()
  (cl-letf (((symbol-function #'hello-world) (lambda (one two) (* one two))))
    (should (= (hello-world 1 2) 2))
    (defadvice! do-something-cool (:override hello-world)
      (+ <one> <two>))
    (should (advice-member-p #'hello-world@do-something-cool #'hello-world))
    (should (= (hello-world 1 2) 3))
    (advice-remove 'hello-world #'hello-world@do-something-cool)
    (should (= (hello-world 1 2) 2)))
  (when (fboundp #'hello-world)
    (fmakunbound #'hello-world))
  (when (fboundp #'hello-world@do-something-cool)
    (fmakunbound #'hello-world@do-something-cool)))
#+end_src

** can handle multiple advice
:PROPERTIES:
:ID:       1a706063-500e-4a12-8887-c757db215e29
:END:

#+begin_src emacs-lisp
(ert-deftest multiple-advices ()
  (cl-letf (((symbol-function 'faa) (lambda () 1))
            ((symbol-function 'foo) (lambda () 2)))
    (should (= (faa) 1))
    (should (= (foo) 2))
    (defadvice! do-something-cool (:override faa foo)
      0)
    (should (advice-member-p #'faa@do-something-cool #'faa))
    (should (advice-member-p #'foo@do-something-cool #'foo))
    (should (zerop (faa)))
    (should (zerop (foo))))
  (when (fboundp #'foo@do-something-cool)
    (fmakunbound #'foo@do-something-cool))
  (when (fboundp #'faa@do-something-cool)
    (fmakunbound #'faa@do-something-cool)))
#+end_src

* hooks
:PROPERTIES:
:ID:       8b71ed59-bf00-48d2-a070-6e7d62f54770
:END:

** hook-p
:PROPERTIES:
:ID:       656dada6-ffb9-4cbc-8568-13b89b2fed14
:END:

#+begin_src emacs-lisp
(ert-deftest void-hook-p ())
#+end_src

** hook name
:PROPERTIES:
:ID:       fb4eaaf3-365d-4248-b95e-dc001c95d70b
:END:

#+begin_src emacs-lisp
(ert-deftest void-hook-name ()
  (alet (void-hook-name 'emacs-lisp-mode-hook 'do-something)
    (should (eq it 'emacs-lisp-mode-hook&do-something))))
#+end_src

** hook variable
:PROPERTIES:
:ID:       3d71878b-ceee-43b9-8a23-e31820418886
:END:

#+begin_src emacs-lisp
(ert-deftest void-hook-var ()
  (alet (void-hook-var 'emacs-lisp-mode-hook&do-something)
    (should (eq it 'emacs-lisp-mode-hook))))
#+end_src

** advice action
:PROPERTIES:
:ID:       9b1fbd9d-fdbd-4622-9d3b-6e2b6ad64827
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-action ()
  (alet (void-advice-action 'emacs-lisp-mode-hook@hello)
    (should (string= "hello" it)))

  (alet (void-advice-action 'emacs-lisp-mode-hook@hello@do-this)
    (should (string= "do-this" it))))
#+end_src

* use-package
:PROPERTIES:
:ID:       ba908b4d-f170-49c9-a469-503340ee2198
:END:

** args or error
:PROPERTIES:
:ID:       ee2ee278-34c4-4c5a-b58c-f62cd38ecf74
:END:

#+begin_src emacs-lisp
#+end_src

** as-one
:PROPERTIES:
:ID:       531081a7-7422-4678-bd5d-b55ff31d81c8
:END:

#+begin_src emacs-lisp
(ert-deftest use-package:unfold-args ()
  (should (equal (use-package:unfold-args '(1 2 3 4) #'numberp)
                 '((1 2 3 4) nil)))
  (should (equal (use-package:unfold-args '((1 2 3 4)) #'numberp)
                 '((1 2 3 4) nil)))
  (should (equal (use-package:unfold-args '((a 2 3 4)) #'numberp)
                 '((a 2 3 4) a))))
#+end_src

** custom use-package keywords
:PROPERTIES:
:ID:       724890eb-4760-400a-9943-3ba25a4772cd
:END:

*** os
:PROPERTIES:
:ID:       63f24710-2c4b-45e6-a293-83ca4aeb9730
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-os ()
  (let ((use-package-expand-minimally t)
        (use-package-always-defer t)
        (use-package-always-ensure nil))
    (should-expand-to! (use-package dummy :os mac :init (+ 1 1))
                       (with-os! (mac) (+ 1 1)))))
#+end_src

*** pre-setq
:PROPERTIES:
:ID:       8b7867bb-6fa7-4702-a90f-0ec9759ec152
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-pre-setq ()
  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil)
        (use-package-always-defer t))

    (should-expand-to! (use-package foo :pre-setq (one . 1))
                       (setq one 1))

    (should-expand-to! (use-package foo :pre-setq (one . 1) (two . 2))
                       (progn (setq one 1) (setq two 2)))

    (should-expand-to! (use-package foo :pre-setq ((one . 1) (two . 2)))
                       (progn (setq one 1) (setq two 2)))))
#+end_src

*** setq
:PROPERTIES:
:ID:       fe536281-6f1e-4096-99ff-da25b63f82c7
:END:

#+begin_src emacs-lisp
(defmacro should-expand-to! (form1 form2)
  `(should (equal (macroexpand-1 ',form1) ',form2)))

(ert-deftest use-package-setq ()
  (let ((use-package-expand-minimally t)
        (use-package-always-defer t)
        (use-package-always-ensure nil))

    (should-expand-to! (use-package foo :setq (one . 1))
                       (after! foo (setq one 1)))

    (should-expand-to! (use-package foo :setq (one . 1) (two . 2))
                       (after! foo (setq one 1) (setq two 2)))

    (should-expand-to! (use-package foo :setq ((one . 1) (two . 2)))
                       (after! foo (setq one 1) (setq two 2)))

    (should-expand-to! (use-package foo :setq (one . 'hook) (two . 'fab))
                       (after! foo (setq one 'hook) (setq two 'fab)))))
#+end_src

*** setq-default
:PROPERTIES:
:ID:       f1751a23-0c0e-4f21-8afb-181ed789fbd1
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-setq-default ()
  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil)
        (use-package-always-defer t))

    (should-expand-to! (use-package foo :setq-default (one . 1))
                       (setq-default one 1))

    (should-expand-to! (use-package foo :setq-default (one . 1) (two . 2))
                       (progn (setq-default one 1) (setq-default two 2)))

    (should-expand-to! (use-package foo :setq-default ((one . 1) (two . 2)))
                       (progn (setq-default one 1) (setq-default two 2)))))
#+end_src

*** before-call
:PROPERTIES:
:ID:       0a38dd5c-28b9-4132-9d13-8c89d474b029
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-before-call ()
  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil)
        (use-package-always-defer t))
    (should-expand-to! (use-package foo :before-call bar)
                       (defadvice! load-foo (:before bar)
                         (require 'foo)))

    (should-expand-to! (use-package foo :before-call bar baz)
                       (defadvice! load-foo (:before bar baz)
                         (require 'foo)))))
#+end_src

*** idle-require
:PROPERTIES:
:ID:       c5374e5c-1c21-4e1b-b34b-3e8d37c51d5b
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-idle-require ()
  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil)
        (use-package-always-defer t))
    (should-expand-to! (use-package foo :idle-require flop) (idle-require 'flop))

    (should-expand-to! (use-package foo :idle-require flop) (idle-require 'flop))

    (should-expand-to! (use-package foo :idle-require flop flap)
                       (progn
                         (idle-require 'flop)
                         (idle-require 'flap)))))
#+end_src

*** alias
:PROPERTIES:
:ID:       342c65b5-082c-4fc0-9b0b-aef6ab194a48
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-alias ()

  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil)
        (use-package-always-defer t))

    (should-expand-to! (use-package foo :alias (one . two))
                       (defalias 'one 'two))

    (should-expand-to! (use-package foo :alias (one . two) (three . four))
                       (progn
                         (defalias 'one 'two)
                         (defalias 'three 'four)))

    (should-expand-to! (use-package foo :alias ((one . two) (three . four)))
                       (progn
                         (defalias 'one 'two)
                         (defalias 'three 'four)))))
#+end_src

*** hook
:PROPERTIES:
:ID:       c1779156-bcf4-4c8f-a555-46c4d99d2ce0
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-hook ()
  (let ((use-package-expand-minimally t)
        (use-package-always-ensure nil))
    (should-expand-to! (use-package foo :hook emacs-startup)
                       (progn (unless (fboundp 'foo-mode)
                                (autoload #'foo-mode "foo" nil t))
                              (void-add-hook 'emacs-startup-hook #'foo-mode)))

    (should-expand-to! (use-package foo :hook emacs-startup-hook)
                       (progn (unless (fboundp 'foo-mode)
                                (autoload #'foo-mode "foo" nil t))
                              (void-add-hook 'emacs-startup-hook #'foo-mode)))

    (should-expand-to! (use-package foo :hook (emacs-startup-hook . dap-mode))
                       (progn (unless (fboundp 'dap-mode)
                                (autoload #'dap-mode "foo" nil t))
                              (void-add-hook 'emacs-startup-hook #'dap-mode)))

    (should-expand-to! (use-package foo :hook ((emacs-startup-hook . dap-mode)))
                       (progn (unless (fboundp 'dap-mode)
                                (autoload #'dap-mode "foo" nil t))
                              (void-add-hook 'emacs-startup-hook #'dap-mode)))))
#+end_src

*** popup
:PROPERTIES:
:ID:       b67e00d2-f531-4f96-bea6-57d06fff14db
:END:

#+begin_src emacs-lisp
(ert-deftest use-package-popup ()
  (should-expand-to! (use-package foo :popup ("\\*fap" (dap)))
                     (push '("\\*fap" (dap)) display-buffer-alist)))
#+end_src
