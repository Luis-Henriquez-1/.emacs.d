* defhook!
:PROPERTIES:
:ID:       130bc7cf-cfb9-43e0-91ba-2035d4b22012
:END:

** accepts multiple hooks
:PROPERTIES:
:ID:       ef5c4f7d-7a25-41cb-b75f-c1c73e8ec4db
:END:

#+begin_src emacs-lisp
(ert-deftest defhook-accepts-multiple-hooks ()
  (let (a-hook b-hook)
    (defhook! hello-world (a-hook b-hook)
      (+ 1 1))
    (should (equal a-hook '(a-hook&hello-world)))
    (should (equal b-hook '(b-hook&hello-world)))
    ;; cleanup
    (fmakunbound 'a-hook&hello-world)
    (fmakunbound 'b-hook&hello-world)))
#+end_src

* defadvice
:PROPERTIES:
:ID:       f9dbab12-fa2d-4486-97b0-70b091d6527c
:END:

** advice-p
:PROPERTIES:
:ID:       2ca4de42-5280-45e3-97ee-ab423c3cb1ad
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-p ()
  (should-not (void-advice-p 'hello))
  (should (void-advice-p 'hello@world)))
#+end_src

** advice-name
:PROPERTIES:
:ID:       2bd281c2-bb9a-4d1b-a926-94854cd1cf9b
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-name ()
  (should (eq (void-advice-name 'hello 'world) 'hello@world))
  (should (void-advice-p (void:advice-name 'hello 'world))))
#+end_src

** advice-target
:PROPERTIES:
:ID:       e3a21c47-8293-49e1-876f-1dd0f054eec1
:END:

#+begin_src emacs-lisp
(ert-deftest void-advice-target ()
  (should (eq 'hello (void-advice-target 'hello@world))))
#+end_src

** add-advice
:PROPERTIES:
:ID:       ad260c52-0830-499a-8880-f5190ba89788
:END:

#+begin_src emacs-lisp
(ert-deftest void-add-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1)))
    ;; test function works.
    (should (= 1 (test-fn)))
    (void-add-advice #'test-fn :override #'ignore)
    ;; successfully advised test function.
    (should (null (test-fn)))
    ;; added `test-fn@ignore' as advice.
    (should (advice-member-p #'test-fn@ignore #'test-fn))))
#+end_src

** remove-advice
:PROPERTIES:
:ID:       80f507e8-053f-45a1-8609-ddf5972874f6
:END:

#+begin_src emacs-lisp
(ert-deftest void-remove-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1)))
    (void-add-advice #'test-fn :override #'ignore)
    (should (advice-member-p #'test-fn@ignore #'test-fn))
    (void-remove-advice #'test-fn #'ignore)
    (should-not (advice-member-p #'test-fn@ignore #'test-fn))))
#+end_src

** expiring advice
:PROPERTIES:
:ID:       7a05e9cd-55d3-4c0d-970b-f2eb60f8a645
:END:

#+begin_src emacs-lisp
(ert-deftest void-expire-advice ()
  (cl-letf (((symbol-function #'test-fn) (lambda () 1))
            ((symbol-function #'test-fn@some-advice) (lambda (&rest _) 0)))
    (should (= 1 (test-fn)))
    (advice-add #'test-fn :override #'test-fn@some-advice)
    ;; `test-fn' was overriden successfully.
    (should (zerop (test-fn)))
    (advice-add #'test-fn@some-advice :around (void-expire-advice #'test-fn@some-advice))
    ;; The expire advice is present.
    (should (advice-member-p #'test-fn@some-advice@expire #'test-fn@some-advice))
    ;; It shouldn't expire immediately.
    (should (zerop (test-fn)))
    ;; ;; Now it should expire.
    (should-not (advice-member-p #'test-fn@some-advice #'test-fn))
    (should (= 1 (test-fn)))
    (should (= 1 (test-fn)))
    ;; The expiring advise should be unbound
    (should-not (boundp #'test-fn@some-advice@expire))
    ;; Works with functions that return t at different times.
    (let ((counter 0))
      (advice-add #'test-fn :override #'test-fn@some-advice)
      (->> (lambda () (= 2 (cl-incf counter)))
           (void-expire-advice #'test-fn@some-advice)
           (advice-add #'test-fn@some-advice :around ))
      (should (zerop (test-fn)))
      (should (zerop (test-fn)))
      (should-not (advice-member-p #'test-fn@some-advice #'test-fn))
      (should (= 1 (test-fn))))))
#+end_src

** does proper thing with around advice
:PROPERTIES:
:ID:       44b4aadc-a579-4b86-bdbc-df965e8d7c89
:END:

#+begin_src emacs-lisp
(ert-deftest around-advice-works ()
  (cl-letf (((symbol-function #'hello-world) (lambda (one two) (* one two))))
    (should (= (hello-world 1 2) 2))
    ;; shouldn't have any advices on it.
    (should-not (advice-mapc (lambda (it _) it) #'hello-world))
    ;; add an around advice.
    (defadvice! do-something-cool (:around hello-world)
      (1+ (apply <orig-fn> <args>)))
    ;; now should have an advice.
    (should (advice-member-p #'hello-world@do-something-cool #'hello-world))
    (should (= (hello-world 1 2) 3))
    ;; remove the advice.
    (advice-remove #'hello-world #'hello-world@do-something-cool)
    (should-not (advice-member-p #'hello-world@do-something-cool #'hello-world))
    ;; should return original value.
    (should (= (hello-world 1 2) 2)))
  (when (fboundp #'hello-world)
    (fmakunbound #'hello-world))
  (when (fboundp #'hello-world@do-something-cool)
    (fmakunbound #'hello-world@do-something-cool)))
#+end_src

** binding works
:PROPERTIES:
:ID:       dc43c155-ae49-463c-9641-60bd15431d97
:END:

#+begin_src emacs-lisp
(ert-deftest other-advices-work ()
  (cl-letf (((symbol-function #'hello-world) (lambda (one two) (* one two))))
    (should (= (hello-world 1 2) 2))
    (defadvice! do-something-cool (:override hello-world)
      (+ <one> <two>))
    (should (advice-member-p #'hello-world@do-something-cool #'hello-world))
    (should (= (hello-world 1 2) 3))
    (advice-remove 'hello-world #'hello-world@do-something-cool)
    (should (= (hello-world 1 2) 2)))
  (when (fboundp #'hello-world)
    (fmakunbound #'hello-world))
  (when (fboundp #'hello-world@do-something-cool)
    (fmakunbound #'hello-world@do-something-cool)))
#+end_src

** can handle multiple advice
:PROPERTIES:
:ID:       1a706063-500e-4a12-8887-c757db215e29
:END:

#+begin_src emacs-lisp
(ert-deftest multiple-advices ()
  (cl-letf (((symbol-function 'faa) (lambda () 1))
            ((symbol-function 'foo) (lambda () 2)))
    (should (= (faa) 1))
    (should (= (foo) 2))
    (defadvice! do-something-cool (:override faa foo)
      0)
    (should (advice-member-p #'faa@do-something-cool #'faa))
    (should (advice-member-p #'foo@do-something-cool #'foo))
    (should (zerop (faa)))
    (should (zerop (foo))))
  (when (fboundp #'foo@do-something-cool)
    (fmakunbound #'foo@do-something-cool))
  (when (fboundp #'faa@do-something-cool)
    (fmakunbound #'faa@do-something-cool)))
#+end_src

* advice
:PROPERTIES:
:ID:       962a1862-2b4d-4e97-94fa-7e874233eeaa
:END:

* hooks
:PROPERTIES:
:ID:       8b71ed59-bf00-48d2-a070-6e7d62f54770
:END:

** void-hook-p
:PROPERTIES:
:ID:       656dada6-ffb9-4cbc-8568-13b89b2fed14
:END:

#+begin_src emacs-lisp
(expect t (void-hook-p 'something&blah))
(expect t (void-hook-p 'something&something))
(expect nil (void-hook-p 'something-random))
#+end_src

** void-hook-variable
:PROPERTIES:
:ID:       417a0d09-b46e-44b9-b783-54acae5ab558
:END:

#+begin_src emacs-lisp
(expect 'the-hook (void-hook-variable 'the-hook&blah))
(expect 'spinach-hook (void-hook-variable 'spinach-hook&blah))
#+end_src

** void-hook-function
:PROPERTIES:
:ID:       5ddbed40-42a7-457c-9668-fd9620589da9
:END:

#+begin_src emacs-lisp
(expect 'the-function (void-hook-function 'hook&the-function))
(expect nil (void-hook-function 'fake-hook))
#+end_src

** void-hook-function-name
:PROPERTIES:
:ID:       67aff07f-ff08-4811-9a3a-f4f2bc0dd033
:END:

#+begin_src emacs-lisp
(expect 'the-hook&something-fn (void-hook-function-name 'the-hook 'something-fn))
(expect 'another-hook&lala (void-hook-function-name 'another-hook 'lalala))
#+end_src

** generate hook
:PROPERTIES:
:ID:       50e883fd-3b30-47c6-8d7d-2c0be92375b6
:END:

#+begin_src emacs-lisp
(expect (void-generate-hook-function))
#+end_src

** void-add-hook 
:PROPERTIES:
:ID:       2f6a0803-6666-4e6d-976c-d1950e0fe211
:END:

#+begin_src emacs-lisp
(let ((some-hook nil))
  (void--add-hook 'some-hook 'turn-on-the-lights nil nil nil)
  (expect '(some-hook&turn-on-the-lights) some-hook)
  ;; TODO: figure out how to determine if a function is an advice
  (expect (fboundp 'some-hook&turn-on-the-lights@log)))
#+end_src

** void-remove-hook
:PROPERTIES:
:ID:       b4986c41-71e6-42a5-bfa9-2f134d22b95c
:END:

#+begin_src emacs-lisp
(let ((some-hook '(some-hook&some-function)))
  ;; (stub 'some-hook&some-function)
  (expect (void-remove-hook 'some-hook&some-function)))
#+end_src

** expire-fn
:PROPERTIES:
:ID:       b3e57612-6df5-4186-9967-8fd0ac2e00fb
:END:

#+begin_src emacs-lisp
(with-stub
  (stub foo)
  (advice-add #'foo :around (void-expire-advice 'foo t))
  (expect (noerror) (foo))
  (expect (error 'void-function-error) (foo))
#+end_src
